// Compile.dwasm v0.1.20170813
// A simple and readable WebAssembly language with self-hosted compiler

// Style conventions:
// Pointers and functions returning pointers start with a Capital letter
// Constants are ALL CAPS

// Memory size in 64kB pages
memory 200 export

// Constants
i32 SIZEINT = 4  // Most browsers currently only support 32bit sized WASM memories
i32 DEC0DE  = 557785600  // Magic number -0x00dec0de - used for debugging

// Global variables
ptr Dwasm  = 0  // Input (string)
ptr Wasm   = 0  // Output binary (string)
ptr Errors = 0  // Error (list)

func ptr main() export
  drop NewString(Dwasm.string_length)  // Fix the heap pointer to include the source string
  Errors = NewList()
  lexx()
  if Errors.list_count.i32 == 0 then 
    parse() 
  end
  if Errors.list_count.i32 == 0 then
    emit() 
  end
  if Errors.list_count.i32 > 0 then 
    parseErrorList() 
  end
  return Wasm + string_length  // Return the memory location of the string
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Lexer 

// Enums
i32 tokens_identifier  = 0x20
i32 tokens_strLiteral  = 0x21
i32 tokens_charLiteral = 0x22
i32 tokens_numLiteral  = 0x23
i32 tokens_true        = 0x24
i32 tokens_false       = 0x25
i32 tokens_lParen      = 0x26
i32 tokens_comma       = 0x27
i32 tokens_rParen      = 0x28
i32 tokens_dot         = 0x29
i32 tokens_fun         = 0x2a
i32 tokens_return      = 0x2b
i32 tokens_end         = 0x1f
i32 tokens_hexwasm     = 0x2d
i32 tokens_drop        = 0x2e
i32 tokens_unreachable = 0x2f
i32 tokens_nop         = 0x30
i32 tokens_iif         = 0x31
i32 tokens_mem         = 0x40
i32 tokens_export      = 0x41
i32 tokens_data        = 0x42
i32 tokens_loop        = 0x43
i32 tokens_continue    = 0x44
i32 tokens_break       = 0x45
i32 tokens_breakif     = 0x46
i32 tokens_if          = 0x48
i32 tokens_then        = 0x49
i32 tokens_elseif      = 0x4a
i32 tokens_else        = 0x4b
i32 tokens_minPrec     = 0x4c
i32 tokens_assign      = 0x4d  // =
i32 tokens_tee         = 0x4e  // :=
i32 tokens_min         = 0x4f
i32 tokens_max         = 0x50
i32 tokens_copysign    = 0x51
i32 tokens_or          = 0x52
i32 tokens_xor         = 0x53
i32 tokens_and         = 0x54
i32 tokens_eq          = 0x55  // ==
i32 tokens_ne          = 0x56  // <>
i32 tokens_lt          = 0x57  // <
i32 tokens_ltu         = 0x58  // <+
i32 tokens_le          = 0x59  // <=
i32 tokens_leu         = 0x5a  // <=+
i32 tokens_gt          = 0x5b  // >
i32 tokens_gtu         = 0x5c  // >+
i32 tokens_ge          = 0x5d  // >=
i32 tokens_geu         = 0x5e  // >=+
i32 tokens_shl         = 0x5f  // <<
i32 tokens_shr         = 0x60  // >>
i32 tokens_shru        = 0x61  // >>+
i32 tokens_rotl        = 0x62
i32 tokens_rotr        = 0x63
i32 tokens_clz         = 0x64 
i32 tokens_ctz         = 0x65 
i32 tokens_cnt         = 0x66 
i32 tokens_add         = 0x67  // +
i32 tokens_sub         = 0x68  // -
i32 tokens_mul         = 0x69  // *
i32 tokens_div         = 0x6a  // /
i32 tokens_divu        = 0x6b  // /+
i32 tokens_mod         = 0x6c
i32 tokens_modu        = 0x6d
i32 tokens_not         = 0x6e
i32 tokens_abs         = 0x6f 
i32 tokens_neg         = 0x70
i32 tokens_ceil        = 0x71
i32 tokens_floor       = 0x72
i32 tokens_trunc       = 0x73
i32 tokens_round       = 0x74
i32 tokens_sqrt        = 0x75
i32 tokens_f64         = 0x7c  // (Data types)
i32 tokens_f32         = 0x7d 
i32 tokens_i64         = 0x7e
i32 tokens_i32         = 0x7f
i32 tokens_bool        = 0x8f  // synonym for i32
i32 tokens_ptr         = 0x9f  // synonym for i32

// Struct
i32 token_dec0de = 0  // debugging marker
i32 token_kind   = 4
i32 token_Value  = 8
i32 token_line   = 12
i32 token_column = 16
i32 token_size   = 20

// Globals
ptr TokenList        = 0
ptr CurrentToken     = 0
ptr CurrentTokenItem = 0
ptr NextToken        = 0

func addToken(i32 kind, i32 Value, i32 line, i32 column)
  i32 Token = Alloc(token_size)
  Token.token_dec0de = 6 - DEC0DE
  Token.token_kind = kind
  Token.token_Value = Value
  Token.token_line = line
  Token.token_column = column
  listAdd(TokenList, Token)
end

func processToken(i32 Val, i32 line, i32 column)
  i32 kind = tokens_identifier
  if     strEqChar(Val, '(')        then kind = tokens_lParen 
  elseif strEqChar(Val, ',')        then kind = tokens_comma 
  elseif strEqChar(Val, ')')        then kind = tokens_rParen 
  elseif strEqChar(Val, 'true')     then kind = tokens_true
  elseif strEqChar(Val, 'false')    then kind = tokens_false
  elseif strEqChar(Val, 'func')     then kind = tokens_fun
  elseif strEqChar(Val, 'return')   then kind = tokens_return
  elseif strEqChar(Val, 'end')      then kind = tokens_end
  elseif strEqChar(Val, 'drop')     then kind = tokens_drop
  elseif strEqChar(Val, 'nop')      then kind = tokens_nop
  elseif strEqChar(Val, 'memory')   then kind = tokens_mem
  elseif strEqChar(Val, 'data')     then kind = tokens_data
  elseif strEqChar(Val, 'export')   then kind = tokens_export
  elseif strEqChar(Val, 'loop')     then kind = tokens_loop
  elseif strEqChar(Val, 'continue') then kind = tokens_continue
  elseif strEqChar(Val, 'break')    then kind = tokens_break
  elseif strEqChar(Val, 'breakif')  then kind = tokens_breakif
  elseif strEqChar(Val, 'if')       then kind = tokens_if
  elseif strEqChar(Val, 'then')     then kind = tokens_then
  elseif strEqChar(Val, 'else')     then kind = tokens_else
  elseif strEqChar(Val, 'elseif')   then kind = tokens_elseif
  elseif strEqChar(Val, 'iif')      then kind = tokens_iif
  elseif strEqChar(Val, 'i32')      then kind = tokens_i32
  elseif strEqChar(Val, 'i64')      then kind = tokens_i64
  elseif strEqChar(Val, 'f32')      then kind = tokens_f32
  elseif strEqChar(Val, 'f64')      then kind = tokens_f64
  elseif strEqChar(Val, 'bool')     then kind = tokens_bool
  elseif strEqChar(Val, 'ptr')      then kind = tokens_ptr
  elseif strEqChar(Val, '=')        then kind = tokens_assign
  elseif strEqChar(Val, ':=')       then kind = tokens_tee
  elseif strEqChar(Val, 'or')       then kind = tokens_or
  elseif strEqChar(Val, 'xor')      then kind = tokens_xor
  elseif strEqChar(Val, 'and')      then kind = tokens_and
  elseif strEqChar(Val, '==')       then kind = tokens_eq
  elseif strEqChar(Val, '<>')       then kind = tokens_ne
  elseif strEqChar(Val, '<')        then kind = tokens_lt
  elseif strEqChar(Val, '<+')       then kind = tokens_ltu
  elseif strEqChar(Val, '<=')       then kind = tokens_le 
  elseif strEqChar(Val, '<=+')      then kind = tokens_leu 
  elseif strEqChar(Val, '>')        then kind = tokens_gt 
  elseif strEqChar(Val, '>+')       then kind = tokens_gtu 
  elseif strEqChar(Val, '>=')       then kind = tokens_ge 
  elseif strEqChar(Val, '>=+')      then kind = tokens_geu   
  elseif strEqChar(Val, '<<')       then kind = tokens_shl 
  elseif strEqChar(Val, '>>')       then kind = tokens_shr 
  elseif strEqChar(Val, '>>>')      then kind = tokens_shru 
  elseif strEqChar(Val, '>>+')      then kind = tokens_shru 
  elseif strEqChar(Val, 'rotl')     then kind = tokens_rotl 
  elseif strEqChar(Val, 'rotr')     then kind = tokens_rotr 
  elseif strEqChar(Val, '+')        then kind = tokens_add 
  elseif strEqChar(Val, '-')        then kind = tokens_sub 
  elseif strEqChar(Val, '*')        then kind = tokens_mul
  elseif strEqChar(Val, '/')        then kind = tokens_div 
  elseif strEqChar(Val, '/+')       then kind = tokens_divu
  elseif strEqChar(Val, 'mod')      then kind = tokens_mod 
  elseif strEqChar(Val, 'modu')     then kind = tokens_modu 
  elseif strEqChar(Val, 'not')      then kind = tokens_not 
  elseif strEqChar(Val, 'neg')      then kind = tokens_neg 
  elseif strEqChar(Val, 'ceiling')  then kind = tokens_ceil
  elseif strEqChar(Val, 'floor')    then kind = tokens_floor
  elseif strEqChar(Val, 'trunc')    then kind = tokens_trunc
  elseif strEqChar(Val, 'round')    then kind = tokens_round
  elseif strEqChar(Val, 'sqrt')     then kind = tokens_sqrt
  elseif strEqChar(Val, 'abs')      then kind = tokens_abs
  elseif strEqChar(Val, 'clz')      then kind = tokens_clz 
  elseif strEqChar(Val, 'ctz')      then kind = tokens_ctz 
  elseif strEqChar(Val, 'cnt')      then kind = tokens_cnt 
  elseif strEqChar(Val, 'copysign') then kind = tokens_copysign
  elseif strEqChar2(Val, 'unreacha', 'ble') then kind = tokens_unreachable
  end
  addToken(kind, Val, line, column)
end

func bool isHexwasm(i32 chr1, i32 chr2, i32 chr3)
  return chr1 == '\' and isNumber(chr2, true) and isNumber(chr3, true)
end

func bool isPunctuator(i32 chr)
  return chr == '(' or chr == ')' or chr == ','
end

func bool isOperatorChar(i32 chr)
  return chr == '=' or chr == '+' or chr == '-' or chr == '/' or chr == '*' or
         chr == '<' or chr == '>' or chr == ':' 
end

func lexx()
  TokenList = NewList()
  i32 pos = -1
  i32 line = 1
  i32 column = 0
  i32 length = Dwasm.string_length
  i32 start = 0
  i32 Val = 0
  loop
    pos = pos + 1
    column = column + 1
    i32 chr = getChar(Dwasm, pos) 

    // newline char
    if chr == 10 then
      line = line + 1
      column = 0
    
    // \00 - \ff 
    elseif isHexwasm(chr, getChar(Dwasm, pos + 1), getChar(Dwasm, pos + 2)) then
      Val = Substring(Dwasm, pos - 1, 4)
      setChar(Val, 0, '0')
      setChar(Val, 1, 'x')
      addToken(tokens_hexwasm, Val, line, column)
      pos = pos + 2
      column = column + 2

    // Identifiers and reserved words
    elseif isAlpha(chr) then
      start = pos
      loop
        if (not isAlpha(chr)) and (not isNumber(chr, false)) then
          pos = pos - 1
          column = column - 1
          break
        end
        pos = pos + 1
        column = column + 1
        chr = getChar(Dwasm, pos)
      end
      Val = Substring(Dwasm, start, pos - start + 1)
      processToken(Val, line, column)
      if getChar(Dwasm, pos + 1) == '.' and isAlpha(getChar(Dwasm, pos + 2)) then
        pos = pos + 1
        column = column + 1
        chr = getChar(Dwasm, pos)
        addToken(tokens_dot, Val, line, column)
      end
    
    // Single quoted chars or long chars up to 64 bit
    elseif chr == 39 then
      pos = pos + 1
      column = column + 1
      chr = getChar(Dwasm, pos)
      start = pos
      loop
        breakif chr == 39
        pos = pos + 1
        column = column + 1
        chr = getChar(Dwasm, pos)
      end
      Val = Substring(Dwasm, start, pos - start)
      decodeString(Val)
      addToken(tokens_charLiteral, Val, line, column)

    // Double quoted strings
    elseif chr == '"' then
      pos = pos + 1
      column = column + 1
      chr = getChar(Dwasm, pos)
      start = pos
      loop
        breakif chr == '"'
        pos = pos + 1
        column = column + 1
        chr = getChar(Dwasm, pos)
      end
      Val = Substring(Dwasm, start, pos - start)
      decodeString(Val)
      addToken(tokens_strLiteral, Val, line, column)

    // Number literals, for example -42, 3.14, 0x8d4f0
    elseif isNumber(chr, false) or ((chr == '-') and isNumber(getChar(Dwasm, pos + 1), false)) then
      start = pos
      bool isHex = false
      loop
        if (not isNumber(chr, isHex)) and (chr <> '-') then
          if start + 1 == pos and chr == 'x' then
            isHex = true
          else
            pos = pos - 1
            column = column - 1
            break
          end
        end
        pos = pos + 1
        column = column + 1
        chr = getChar(Dwasm, pos)
      end
      if chr == '.' and not isHex then
        pos = pos + 2
        column = column + 2
        chr = getChar(Dwasm, pos)
        loop
          if (not isNumber(chr, isHex)) then
            pos = pos - 1
            column = column - 1
            break
          end
          pos = pos + 1
          column = column + 1
          chr = getChar(Dwasm, pos)
        end
      end
      Val = Substring(Dwasm, start, pos - start + 1)
      addToken(tokens_numLiteral, Val, line, column)

    // Comments
    elseif chr == '/' and getChar(Dwasm, pos + 1) == '/' then
      loop
        if chr == 10 or chr == 13 then  // LF or CR
          column = 0
          line = line + 1
          break
        end
        pos = pos + 1
        column = column + 1
        chr = getChar(Dwasm, pos)
      end
    
    // Parenthases and commas
    elseif isPunctuator(chr) then
      Val = Substring(Dwasm, pos, 1)
      processToken(Val, line, column)

    // Mathematical operators
    elseif isOperatorChar(chr) then
      if isOperatorChar(getChar(Dwasm, pos + 1)) then
        if isOperatorChar(getChar(Dwasm, pos + 2)) then
          Val = Substring(Dwasm, pos, 3)
          pos = pos + 2
          column = column + 2
        else
          Val = Substring(Dwasm, pos, 2)
          pos = pos + 1
          column = column + 1
        end
      else
        Val = Substring(Dwasm, pos, 1)
      end
      processToken(Val, line, column)

    end
    breakif pos >= length
  end
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Scoper

// Struct
i32 scope_dec0de     = 0   // debugging marker
i32 scope_Node       = 4
i32 scope_index      = 8
i32 scope_Parent     = 12
i32 scope_Symbols    = 16
i32 scope_localIndex = 20
i32 scope_size       = 24

// Globals
ptr CurrentScope = 0
ptr GlobalScope  = 0

func pushScope(i32 Node)
  i32 Scope = Alloc(scope_size)
  Scope.scope_dec0de = 3 - DEC0DE
  Scope.scope_Symbols = NewList()
  Scope.scope_Node = Node
  if CurrentScope then
    Scope.scope_index.i32 = CurrentScope.scope_index + 1
    Scope.scope_Parent = CurrentScope
  end
  Node.node_Scope = Scope
  CurrentScope = Scope
end

func popScope()
  CurrentScope = CurrentScope.scope_Parent
end

func ptr LookupFunctionScope(ptr Scope)
  ptr FunScope = Scope
  loop
    breakif not FunScope  // error
    breakif FunScope.scope_Node.node_kind == nodes_fun
    breakif FunScope.scope_Node.node_kind == nodes_program
    FunScope = FunScope.scope_Parent
  end
  return FunScope
end

func scopeRegister(ptr Scope, ptr Name, ptr Node, ptr Token)
  if ListSearch(Scope.scope_Symbols, Name) then
    addError(error_duplicateName, Token)
  end
  i32 nodeKind = Node.node_kind
  listAddName(Scope.scope_Symbols, Node, Name)
  if nodeKind == nodes_variable or nodeKind == nodes_parameter then
    ptr FunScope = LookupFunctionScope(Scope)
    i32 nextIndex = FunScope.scope_localIndex
    Node.node_Scope = FunScope
    Node.node_index = nextIndex
    FunScope.scope_localIndex = nextIndex + 1
  end
end

func ptr ScopeResolve(ptr Scope, ptr Name, ptr Token)
  ptr Node = 0
  ptr RecurseScope = Scope
  loop
    breakif not RecurseScope
    Node = ListSearch(RecurseScope.scope_Symbols, Name)
    breakif Node
    RecurseScope = RecurseScope.scope_Parent
  end
  if not Node then
    addError(error_notDeclared, Token)
  end
  return Node
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Parser 

// Enums
i32 nodes_program    = 0x01  // root node
i32 nodes_fun        = 0x02
i32 nodes_block      = 0x03
i32 nodes_return     = 0x04
i32 nodes_variable   = 0x05
i32 nodes_parameter  = 0x06
i32 nodes_identifier = 0x07
i32 nodes_literal    = 0x08
i32 nodes_binary     = 0x09
i32 nodes_unary      = 0x0a
i32 nodes_call       = 0x0b
i32 nodes_if         = 0x0c
i32 nodes_loop       = 0x0d
i32 nodes_break      = 0x0e
i32 nodes_continue   = 0x0f
i32 nodes_hexwasm    = 0x10  // WebAssembly code byte e.g. tokens_nop
i32 nodes_breakif    = 0x11
i32 nodes_mem        = 0x12
i32 nodes_data       = 0x13
i32 nodes_dotLoad    = 0x14
i32 nodes_dotStore   = 0x15
i32 nodes_drop       = 0x16
i32 nodes_iif        = 0x17
i32 nodes_assign     = 0x18

// Structs
i32 node_dec0de     = 0   // debugging marker
i32 node_kind       = 4   // From the nodes_ enum
i32 node_index      = 8   // Zero based index number for funs, variables, parameters
i32 node_String     = 12  // Literal value, or fun/var/parameter name
i32 node_Scope      = 16  // Scope for program/block/loop/fun used for name resolution
i32 node_ANode      = 20  // Binary left, call fun, return expression, then block, or fun body
i32 node_BNode      = 24  // Binary/unary right, else block, fun return, variable assignment
i32 node_CNode      = 28  // If statement condition node
i32 node_Nodes      = 32  // List of child nodes for program/block, or fun locals
i32 node_ParamNodes = 36  // List of params for call/fun
i32 node_type       = 40  // From the tokens_ enum
i32 node_dataType   = 44  // inferred data type
i32 node_Token      = 48
i32 node_size       = 52

// Globals
ptr RootNode   = 0
ptr ExportList = 0
ptr DataList   = 0
ptr MemExport  = 0
i32 funIndex   = 0  // Next function index number
i32 memMin     = 0
i32 memMax     = 0

func ptr NewNode(i32 kind)
  ptr Node = Alloc(node_size)
  Node.node_dec0de = 2 - DEC0DE
  Node.node_Scope = CurrentScope
  Node.node_Token = CurrentToken
  Node.node_kind = kind
  return Node
end

func nextToken()
  CurrentTokenItem = CurrentTokenItem.item_Next
  if CurrentTokenItem then
    CurrentToken = CurrentTokenItem.item_Object
  else
    CurrentToken = 0
  end
  ptr NextTokenItem = CurrentTokenItem.item_Next
  if NextTokenItem then
    NextToken = NextTokenItem.item_Object
  else
    NextToken = 0
  end
end

func bool isBinaryOperator(ptr Token)
  i32 kind = Token.token_kind
  return kind == tokens_add or kind == tokens_sub or kind == tokens_mul or kind == tokens_div or
         kind == tokens_mod or kind == tokens_modu or kind == tokens_or or kind == tokens_and or
         kind == tokens_lt or kind == tokens_eq or kind == tokens_ne or kind == tokens_lt or
         kind == tokens_le or kind == tokens_gt or kind == tokens_ge or kind == tokens_shl or
         kind == tokens_shr or kind == tokens_xor or kind == tokens_ltu or kind == tokens_leu or 
         kind == tokens_gtu or kind == tokens_geu or kind == tokens_shru or kind == tokens_rotl or
         kind == tokens_rotr or kind == tokens_tee
end

func bool isUnaryOperator(ptr Token)
  i32 kind = Token.token_kind
  return kind == tokens_sub or kind == tokens_not or kind == tokens_cnt or kind == tokens_clz or 
         kind == tokens_ctz or kind == tokens_abs or kind == tokens_neg or kind == tokens_ceil or
         kind == tokens_floor or kind == tokens_trunc or kind == tokens_round or kind == tokens_sqrt 
end

func bool isLiteral(ptr Token)
  i32 kind = Token.token_kind
  return kind == tokens_numLiteral or kind == tokens_charLiteral or 
         kind == tokens_true or kind == tokens_false
end

func bool isNativeType(ptr Token)
  i32 kind = Token.token_kind
  return kind == tokens_i32 or kind == tokens_i64 or kind == tokens_f32 or kind == tokens_f64 or 
         kind == tokens_bool or kind == tokens_ptr
end

func eatToken(i32 kind)
  if CurrentToken then
    if CurrentToken.token_kind == kind then
      nextToken()
    else
      addError(error_invalidToken, CurrentToken)
    end
  else
    i32 LastToken = TokenList.list_Last.item_Object
    addError(error_missingToken, LastToken)
  end
end

func eatTokens(i32 kind, i32 kind2)
  if CurrentToken then
    if CurrentToken.token_kind == kind or CurrentToken.token_kind == kind2 then
      nextToken()
    else
      addError(error_invalidToken, CurrentToken)
    end
  else
    i32 LastToken = TokenList.list_Last.item_Object
    addError(error_missingToken, LastToken)
  end
end

func ptr ParseFunParams()
  ptr Params = NewList()
  eatToken(tokens_lParen)
  loop
    i32 type = CurrentToken.token_kind
    breakif type == tokens_rParen
    nextToken()
    ptr FunParamNode = NewNode(nodes_parameter)
    FunParamNode.node_type = type
    FunParamNode.node_dataType = type
    ptr Name = CurrentToken.token_Value
    FunParamNode.node_String = Name
    listAddName(Params, FunParamNode, Name)
    nextToken()
    breakif CurrentToken.token_kind <> tokens_comma
    eatToken(tokens_comma)
  end
  eatToken(tokens_rParen)
  return Params
end

func ptr ParseFunBlock()
  ptr Node = NewNode(nodes_block)
  ptr BodyList = NewList()
  Node.node_Nodes = BodyList
  Node.node_Scope = CurrentScope
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind == tokens_end
    ptr ChildNode = ParseStatement()
    breakif not ChildNode
    listAdd(BodyList, ChildNode)
  end
  return Node
end

func ptr ParseFun()
  i32 type = 0
  eatToken(tokens_fun)
  if isNativeType(CurrentToken) then
    type = CurrentToken.token_kind
    nextToken()
  end
  ptr Name = CurrentToken.token_Value
  ptr Node = NewNode(nodes_fun)
  scopeRegister(CurrentScope, Name, Node, CurrentToken)
  nextToken()
  ptr Locals = NewList()
  Node.node_index = funIndex
  funIndex = funIndex + 1
  Node.node_type = type
  Node.node_dataType = type
  Node.node_String = Name
  Node.node_Nodes = Locals
  ptr ParamList = ParseFunParams()
  Node.node_ParamNodes = ParamList
  pushScope(Node)
  ptr ParamItem = ParamList.list_First
  loop
    breakif not ParamItem
    ptr ParamName = ParamItem.item_Name
    scopeRegister(CurrentScope, ParamName, ParamItem.item_Object, ParamItem.item_Object.node_Token)
    ParamItem = ParamItem.item_Next
  end
  if CurrentToken.token_kind == tokens_export then
    eatToken(tokens_export)
    if CurrentToken.token_kind == tokens_strLiteral then
      listAddName(ExportList, Node, CurrentToken.token_Value)
      eatToken(tokens_strLiteral)
    else
      listAddName(ExportList, Node, Name)
    end
  end
  Node.node_ANode = ParseFunBlock()
  popScope()
  eatToken(tokens_end)
  return Node
end

func ptr ParseBreak()
  ptr Node = NewNode(nodes_break)
  eatToken(tokens_break)
  return Node
end

func ptr ParseContinue()
  ptr Node = NewNode(nodes_continue)
  eatToken(tokens_continue)
  return Node
end

func ptr ParseLiteral()
  ptr Node = NewNode(nodes_literal)
  Node.node_String.ptr = CurrentToken.token_Value
  Node.node_type.i32 = CurrentToken.token_kind
  nextToken()
  return Node
end

func ptr ParseIdentifier()
  ptr Node = NewNode(nodes_identifier)
  Node.node_String.ptr = CurrentToken.token_Value
  Node.node_type.i32 = CurrentToken.token_kind
  nextToken()
  return Node
end

func ptr ParseCallParams()
  ptr ParamList = NewList()
  eatToken(tokens_lParen)
  loop
    breakif CurrentToken.token_kind == tokens_rParen
    listAdd(ParamList, ParseExpression(tokens_minPrec))
    breakif CurrentToken.token_kind <> tokens_comma
    eatToken(tokens_comma)
  end
  eatToken(tokens_rParen)
  return ParamList
end

func ptr ParseCallExpression(ptr Callee)
  ptr Node = NewNode(nodes_call)
  Node.node_ANode = Callee
  Node.node_ParamNodes = ParseCallParams()
  return Node
end

func ptr parseUnaryExpression()
  ptr Node = NewNode(nodes_unary)
  Node.node_type.i32 = CurrentToken.token_kind
  Node.node_String.ptr = CurrentToken.token_Value
  nextToken()
  Node.node_BNode = ParseExpression(tokens_add)
  return Node
end

func ptr ParseDotLoad()
  ptr Node = NewNode(nodes_dotLoad)
  ptr BodyList = NewList()
  Node.node_Nodes = BodyList
  listAdd(BodyList, ParseIdentifier())
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind <> tokens_dot
    eatToken(tokens_dot)
    if isNativeType(CurrentToken) then
      Node.node_dataType.i32 = CurrentToken.token_kind 
      nextToken()
      break
    else
      listAdd(BodyList, ParseIdentifier())
    end
  end
  return Node
end

// A.B.C.i32 = x
func ptr ParseDotStore()
  ptr Node = NewNode(nodes_dotStore)
  ptr BodyList = NewList()
  i32 dataType = 0
  Node.node_Nodes = BodyList
  listAdd(BodyList, ParseIdentifier())
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind <> tokens_dot
    eatToken(tokens_dot)
    if isNativeType(CurrentToken) then
      dataType = CurrentToken.token_kind
      Node.node_dataType = dataType 
      nextToken()
      break
    else
      listAdd(BodyList, ParseIdentifier())
    end
  end
  eatToken(tokens_assign)
  Node.node_ANode = ParseExpression(tokens_minPrec)
  Node.node_ANode.node_dataType = dataType
  return Node
end

func ptr ParsePrefix()
  ptr Node = 0
  i32 kind = CurrentToken.token_kind
  if isLiteral(CurrentToken) then
    Node = ParseLiteral()
  elseif kind == tokens_iif then
    Node = ParseIifExpression()
  elseif kind == tokens_identifier then
    i32 nextKind = 0
    if NextToken then nextKind = NextToken.token_kind end
    if nextKind == tokens_dot then
      Node = ParseDotLoad()
    else
      Node = ParseIdentifier()
    end
  elseif kind == tokens_lParen then
    nextToken()
    Node = ParseExpression(tokens_minPrec)
    eatToken(tokens_rParen)
  elseif isUnaryOperator(CurrentToken) then
    Node = parseUnaryExpression()
  end
  return Node
end

func ptr ParseBinaryExpression(i32 level, ptr Left)
  ptr Node = 0
  i32 precedence = CurrentToken.token_kind  // node_kind doubles as the precedence
  if level > precedence then
    Node = Left
  else
    Node = NewNode(nodes_binary)
    Node.node_type.i32 = CurrentToken.token_kind
    Node.node_String.ptr = CurrentToken.token_Value
    Node.node_ANode = Left
    nextToken()
    Node.node_BNode = ParseExpression(precedence)
  end
  return Node
end

func ptr ParseAssignStatement()
  ptr Node = NewNode(nodes_assign)
  Node.node_ANode = ParseIdentifier()
  Node.node_type = tokens_assign
  Node.node_String.ptr = CurrentToken.token_Value
  eatToken(tokens_assign)
  Node.node_BNode = ParseExpression(tokens_minPrec)
  return Node
end

func ptr ParseInfix(i32 level, ptr Left)
  ptr Node = 0
  if isBinaryOperator(CurrentToken) then
    Node = ParseBinaryExpression(level, Left)
  elseif CurrentToken.token_kind == tokens_lParen then
    Node = ParseCallExpression(Left)
    Node.node_Token.i32 = Left.node_Token
  else
    Node = Left
  end
  return Node
end

func ptr ParseCallStatement()
  ptr IdentifierNode = ParseIdentifier()
  ptr Node = ParseCallExpression(IdentifierNode)
  return Node
end

func ptr ParseBreakif()
  ptr Node = NewNode(nodes_breakif)
  eatToken(tokens_breakif)
  Node.node_CNode = ParseExpression(tokens_minPrec)
  return Node
end

func ptr ParseDrop()
  ptr Node = NewNode(nodes_drop)
  eatToken(tokens_drop)
  Node.node_CNode = ParseExpression(tokens_minPrec)
  return Node
end

func ptr ParseExpression(i32 level)
  ptr Node = ParsePrefix()
  loop
    breakif not CurrentToken
    ptr Expr = ParseInfix(level, Node)
    breakif Expr == 0 or Expr == Node
    Node = Expr
  end
  return Node
end

func ptr ParseHexwasmStatement()
  ptr Node = NewNode(nodes_hexwasm)
  Node.node_type = strToI32(CurrentToken.token_Value, CurrentToken)
  eatToken(tokens_hexwasm)
  return Node
end

func ptr ParseUnreachableStatement()
  ptr Node = NewNode(nodes_hexwasm)
  Node.node_type = 0x00
  eatToken(tokens_unreachable)
  return Node
end

func ptr ParseNopStatement()
  ptr Node = NewNode(nodes_hexwasm)
  Node.node_type = 0x01
  eatToken(tokens_nop)
  return Node
end

func ptr ParseReturnStatement()
  ptr Node = NewNode(nodes_return)
  eatToken(tokens_return)
  Node.node_ANode = ParseExpression(tokens_minPrec)
  return Node
end

func ptr ParseIfBlock()
  ptr Node = NewNode(nodes_block)
  ptr BodyList = NewList()
  Node.node_Nodes = BodyList
  Node.node_Scope = CurrentScope
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind == tokens_else
    breakif CurrentToken.token_kind == tokens_elseif
    breakif CurrentToken.token_kind == tokens_end
    ptr ChildNode = ParseStatement()
    breakif not ChildNode
    listAdd(BodyList, ChildNode)
  end
  return Node
end

func ptr ParseIfStatement(bool isElseif)
  ptr Node = NewNode(nodes_if)
  if not isElseif then eatToken(tokens_if) end
  Node.node_CNode = ParseExpression(tokens_minPrec)
  eatToken(tokens_then)
  pushScope(Node)
  Node.node_ANode = ParseIfBlock()
  popScope()
  if CurrentToken.token_kind == tokens_elseif then
    eatToken(tokens_elseif)
    pushScope(Node)
    Node.node_BNode = ParseIfStatement(true)
    popScope()
  end
  if CurrentToken.token_kind == tokens_else then
    eatToken(tokens_else)
    pushScope(Node)
    Node.node_BNode = ParseIfBlock()
    popScope()
  end
  if not isElseif then eatToken(tokens_end) end
  return Node
end

func ptr ParseIifExpression()
  ptr Node = NewNode(nodes_iif)
  eatToken(tokens_iif)
  Node.node_CNode = ParseExpression(tokens_minPrec)
  eatToken(tokens_then)
  Node.node_ANode = ParseExpression(tokens_minPrec)
  eatToken(tokens_else)
  Node.node_BNode = ParseExpression(tokens_minPrec)
  eatToken(tokens_end)
  return Node
end

func ptr ParseLoopBlock()
  ptr Node = NewNode(nodes_block)
  ptr BodyList = NewList()
  Node.node_Nodes = BodyList
  Node.node_Scope = CurrentScope
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind == tokens_end
    ptr ChildNode = ParseStatement()
    breakif not ChildNode
    listAdd(BodyList, ChildNode)
  end
  return Node
end

func ptr ParseLoopStatement()
  ptr Node = NewNode(nodes_loop)
  eatToken(tokens_loop)
  pushScope(Node)
  Node.node_ANode = ParseLoopBlock()
  popScope()
  eatToken(tokens_end)
  return Node
end

func ptr ParseDeclaration()
  i32 type = CurrentToken.token_kind
  nextToken()
  ptr Name = CurrentToken.token_Value
  ptr NameToken = CurrentToken
  nextToken()
  ptr Node = NewNode(nodes_variable)
  Node.node_type = type
  Node.node_dataType = type
  Node.node_String = Name
  scopeRegister(CurrentScope, Name, Node, NameToken)
  eatToken(tokens_assign)
  Node.node_BNode = ParseExpression(tokens_minPrec)
  if CurrentScope.scope_Parent.ptr then
    ptr FunScope = LookupFunctionScope(CurrentScope)
    ptr FunNode = FunScope.scope_Node
    ptr FunLocalsList = FunNode.node_Nodes
    if not FunLocalsList then
      FunLocalsList = NewList()
      FunNode.node_Nodes = FunLocalsList
    end
    listAdd(FunLocalsList, Node)
  end
  return Node
end

func ptr ParseMem()
  ptr Node = NewNode(nodes_mem)
  ptr MemToken = CurrentToken
  eatToken(tokens_mem)
  memMin = strToI32(CurrentToken.token_Value, CurrentToken)
  nextToken()
  if CurrentToken.token_kind == tokens_numLiteral then
    memMax = strToI32(CurrentToken.token_Value, CurrentToken)
    nextToken()
  end
  if CurrentToken.token_kind == tokens_export then
    eatToken(tokens_export)
    if CurrentToken.token_kind == tokens_strLiteral then
      MemExport = CurrentToken.token_Value
      nextToken()
    else
      MemExport = MemToken.token_Value
    end
  end
  return Node
end

func ptr ParseData()
  ptr Node = NewNode(nodes_data)
  eatToken(tokens_data)
  if CurrentToken.token_kind == tokens_numLiteral then
    ptr OffsetToken = CurrentToken
    Node.node_ANode = OffsetToken
    nextToken()
    if CurrentToken.token_kind == tokens_strLiteral then
      listAddName(DataList, OffsetToken, CurrentToken)
      Node.node_BNode = CurrentToken
      nextToken()
    end
  end
  return Node
end

func ptr ParseStatement()
  ptr Node = 0
  i32 kind = CurrentToken.token_kind
  if isNativeType(CurrentToken) then
    Node = ParseDeclaration()
  elseif kind == tokens_return then
    Node = ParseReturnStatement()
  elseif kind == tokens_hexwasm then
    Node = ParseHexwasmStatement()
  elseif kind == tokens_unreachable then
    Node = ParseUnreachableStatement()
  elseif kind == tokens_nop then
    Node = ParseNopStatement()
  elseif kind == tokens_if then
    Node = ParseIfStatement(false)
  elseif kind == tokens_loop then
    Node = ParseLoopStatement()
  elseif kind == tokens_breakif then
    Node = ParseBreakif()
  elseif kind == tokens_drop then
    Node = ParseDrop()
  elseif kind == tokens_continue then
    Node = ParseContinue()
  elseif kind == tokens_break then
    Node = ParseBreak()
  elseif kind == tokens_identifier and NextToken.token_kind == tokens_dot then
    Node = ParseDotStore()
  elseif kind == tokens_identifier and NextToken.token_kind == tokens_lParen then
    Node = ParseCallStatement()
  elseif kind == tokens_identifier and NextToken.token_kind == tokens_assign then
    Node = ParseAssignStatement()
  else
    addError(error_blockStatement, CurrentToken)
  end
  return Node
end

func ptr ParseRootStatement()
  ptr Node = 0
  i32 kind = CurrentToken.token_kind
  if isNativeType(CurrentToken) then
    Node = ParseDeclaration()  // Globals
  elseif kind == tokens_mem then
    Node = ParseMem()
  elseif kind == tokens_data then
    Node = ParseData()
  elseif kind == tokens_fun then
    Node = ParseFun()
  elseif kind == tokens_hexwasm then
    Node = ParseHexwasmStatement()
  else
    addError(error_rootStatement, CurrentToken)
  end
  return Node
end

func parse()
  RootNode = NewNode(nodes_program)
  ExportList = NewList()
  DataList = NewList()
  CurrentTokenItem = TokenList.list_First
  CurrentToken = CurrentTokenItem.item_Object
  pushScope(RootNode)
  GlobalScope = CurrentScope  
  ptr BodyList = NewList()
  RootNode.node_Nodes = BodyList
  loop
    breakif not CurrentToken
    ptr Child = ParseRootStatement()
    breakif not Child
    listAdd(BodyList, Child)
  end
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Compiler 

// Globals
ptr CurrentFunNode  = 0
ptr TypeList        = 0
ptr FunTypeList     = 0
i32 emitGlobalCount = 0

func emit()
  Wasm = NewEmptyString(Dwasm.string_length + 256)  // Guess
  CurrentScope = RootNode.node_Scope
  emitHeader()
  TypeList = NewList()
  FunTypeList = NewList()
  emitTypeSection()
  emitFunctionSection()
  emitMemorySection()
  emitGlobalSection()
  emitExportSection()
  emitCodeSection()
  emitDataSection()
end

func emitHeader()
  appendI32(Wasm, '\00asm')  // Wasm magic: 00 61 73 6d
  appendI32(Wasm, 1)         // Wasm version
end

func emitTypeSection()
  ptr BodyList = RootNode.node_Nodes
  i32 skip = Wasm.string_length
  if BodyList then
    appendByte(Wasm, 0x01)  // Type section
    appendByte(Wasm, 0x00)  // section size (guess)
    ptr Start = Wasm.string_length 
    appendByte(Wasm, 0x00)  // types count (guess)  
    i32 index = 0
    i32 Item = BodyList.list_First
    loop
      breakif not Item
      i32 Node = Item.item_Object
      if Node.node_kind == nodes_fun then
        emitType(Node, index)
        index = index + 1
      end
      Item = Item.item_Next
    end
    i32 count = TypeList.list_count
    i32 length = Wasm.string_length - Start
    i32 offset = uLebLength(count) - 1 + uLebLength(length) - 1
    offsetTail(Wasm, Start, offset)
    Wasm.string_length = Start - 1
    appendUleb(Wasm, length + uLebLength(count) - 1)
    appendUleb(Wasm, count)
    Wasm.string_length = Wasm.string_length + length - 1
  end
  if not FunTypeList.list_count.i32 then Wasm.string_length = skip end
end

func emitType(ptr Node, i32 funcNo)
  ptr ParamList = Node.node_ParamNodes
  i32 params = ParamList.list_count
  i32 returns = iif Node.node_type.i32 then 1 else 0 end
  ptr TypeString = NewEmptyString(1 + uLebLength(params) + params + uLebLength(returns) + returns)
  appendChar(TypeString, 0x60)  // fun type
  appendUleb(TypeString, params)
  ptr ParamItem = ParamList.list_First
  loop
    breakif not ParamItem
    i32 dataType = ParamItem.item_Object.node_type
    if dataType == tokens_bool or dataType == tokens_ptr then 
      appendChar(TypeString, i32_i64(tokens_i32))
    else
      appendChar(TypeString, i32_i64(dataType))
    end    
    ParamItem = ParamItem.item_Next
  end
  i32 returnType = Node.node_type
  if returnType then
    appendUleb(TypeString, 0x01)  // return count
    if returnType == tokens_bool or returnType == tokens_ptr then 
      appendChar(TypeString, i32_i64(tokens_i32))
    else
      appendChar(TypeString, i32_i64(returnType))
    end
  else
    appendUleb(TypeString, 0x00)  // return count
  end
  i32 typeIndex = indexListSearch(TypeList, TypeString)
  if typeIndex == -1 then
    typeIndex = TypeList.list_count
    listAddName(TypeList, 0, TypeString)
    appendString(Wasm, TypeString)
  end
  listAdd(FunTypeList, typeIndex)
end

func emitFunctionSection()
  i32 funCount = FunTypeList.list_count
  if funCount then
    appendByte(Wasm, 0x03)  // Function section
    appendByte(Wasm, 0x00)  // section size (guess)
    i32 start = Wasm.string_length 
    appendUleb(Wasm, funCount)  // types count
    ptr FunType = FunTypeList.list_First
    loop
      breakif not FunType
      appendUleb(Wasm, FunType.item_Object)
      FunType = FunType.item_Next
    end
    i32 length = Wasm.string_length - start
    i32 offset = uLebLength(length) - 1
    offsetTail(Wasm, start, offset)
    Wasm.string_length = start - 1
    appendUleb(Wasm, length)
    Wasm.string_length = Wasm.string_length + length
  end
end

func emitMemorySection()
  if memMin or memMax then
    appendByte(Wasm, 0x05)  // Memory section
    if memMax then
      if memMax < memMin then memMax = memMin end
      appendUleb(Wasm, 2 + uLebLength(memMin) + uLebLength(memMax))  // Size in bytes
      appendByte(Wasm, 0x01)    // Count. A maximum of 1 currently in WebAssembly
      appendByte(Wasm, 0x01)    // Resizable
      appendUleb(Wasm, memMin)  // Pages
      appendUleb(Wasm, memMax)  // Pages
    else
      appendUleb(Wasm, 2 + uLebLength(memMin))  // Size in bytes
      appendByte(Wasm, 0x01)    // Count
      appendByte(Wasm, 0x00)    // Resizable
      appendUleb(Wasm, memMin)  // Pages
    end
  end
end

func emitGlobalSection()
  i32 skip = Wasm.string_length
  if RootNode.node_Nodes.i32 then
    appendByte(Wasm, 0x06)  // Section code
    appendByte(Wasm, 0x00)  // Section size (guess)
    i32 start = Wasm.string_length 
    appendByte(Wasm, 0x00)  // Globals count (guess)
    ptr Item = RootNode.node_Nodes.list_First
    i32 count = 0
    loop
      breakif not Item
      if Item.item_Object.node_kind == nodes_variable then
        emitNativeGlobal(Item.item_Object)
        count = count + 1
        emitGlobalCount = emitGlobalCount + 1
      end
      Item = Item.item_Next
    end
    i32 length = Wasm.string_length - start
    i32 offset = uLebLength(count) - 1 + uLebLength(length) - 1
    offsetTail(Wasm, start, offset)
    Wasm.string_length = start - 1
    appendUleb(Wasm, length + uLebLength(count) - 1)
    appendUleb(Wasm, count)
    Wasm.string_length = Wasm.string_length + length - 1
  end
  if not emitGlobalCount then
    Wasm.string_length = skip 
  end
end

func emitNativeGlobal(i32 Node)
  i32 dataType = Node.node_type  // Native type
  if dataType == tokens_f64 then 
    appendByte(Wasm, dataType)
    appendByte(Wasm, 0x01)  // Mutable
    appendByte(Wasm, 0x44)  // f64.const
  elseif dataType == tokens_f32 then 
    appendByte(Wasm, dataType)
    appendByte(Wasm, 0x01)  // Mutable
    appendByte(Wasm, 0x43)  // f32.const
  elseif dataType == tokens_i64 then
    appendByte(Wasm, dataType)
    appendByte(Wasm, 0x01)  // Mutable
    appendByte(Wasm, 0x42)  // i64.const
  else  // i32, bool, ptr
    appendByte(Wasm, tokens_i32)
    appendByte(Wasm, 0x01)  // Mutable
    appendByte(Wasm, 0x41)  // i32.const
  end
  i32 Value = Node.node_BNode.node_String
  i32 nodeType = Node.node_BNode.node_type
  if nodeType == tokens_true then
    appendByte(Wasm, 0x01) 
  elseif nodeType == tokens_false then 
    appendByte(Wasm, 0x00) 
  elseif dataType == tokens_f64 then
    appendF64(Wasm, strToF64(Value))
  elseif dataType == tokens_f32 then
    appendF32(Wasm, strToF32(Value))
  elseif dataType == tokens_i64 then
    appendSleb64(Wasm, strToI64(Value, Node.node_BNode.node_Token))
  else
    appendSleb32(Wasm, strToI32(Value, Node.node_BNode.node_Token))
  end
  appendByte(Wasm, 0x0b)  // end
end

func emitExportSection()
  ptr BodyList = RootNode.node_Nodes
  if BodyList then
    i32 count = ExportList.list_count
    if MemExport then count = count + 1 end
    if count then
      appendByte(Wasm, 0x07)  // Export section
      appendByte(Wasm, 0x00)  // Section size (guess)
      i32 start = Wasm.string_length
      appendUleb(Wasm, count)  // Export count
      if MemExport then
        emitExportMem()
      end
      if ExportList.list_count.i32 then
        emitExportFuns()
      end
      i32 length = Wasm.string_length - start
      i32 offset = uLebLength(length) - 1
      offsetTail(Wasm, start, offset)
      Wasm.string_length = start - 1
      appendUleb(Wasm, length)
      Wasm.string_length = Wasm.string_length + length
    end
  end
end

func emitExportFuns()
  ptr Item = ExportList.list_First
  loop
    ptr Name = Item.item_Name
    appendUleb(Wasm, Name.string_length)
    appendString(Wasm, Name)
    appendByte(Wasm, 0x00)  // Type: function
    appendUleb(Wasm, Item.item_Object.node_index)
    Item = Item.item_Next
    breakif not Item
  end
end

func emitExportMem()
  appendUleb(Wasm, MemExport.string_length)
  appendString(Wasm, MemExport)
  appendByte(Wasm, 0x02)  // Type: memory
  appendByte(Wasm, 0x00)  // Memory number 0 
end

func emitCodeSection()
  if FunTypeList.list_count.i32 then
    appendByte(Wasm, 0x0a)  // Code section
    appendByte(Wasm, 0x00)  // Section size (guess)
    i32 start = Wasm.string_length  
    appendUleb(Wasm, FunTypeList.list_count)
    ptr FunItem = RootNode.node_Nodes.list_First
    loop
      ptr FunNode = FunItem.item_Object
      if FunNode.node_kind == nodes_fun then
        emitFunNode(FunNode)
      end
      FunItem = FunItem.item_Next
      breakif not FunItem
    end
    i32 length = Wasm.string_length - start
    i32 offset = uLebLength(length) - 1
    offsetTail(Wasm, start, offset)
    Wasm.string_length = start - 1
    appendUleb(Wasm, length)
    Wasm.string_length = Wasm.string_length + length
  end
end

func emitFunNode(ptr Node)
  CurrentFunNode = Node
  appendByte(Wasm, 0x00)  // Function size (guess)
  i32 start = Wasm.string_length 
  appendByte(Wasm, 0x00)  // Local declaration count (guess)
  ptr LocalList = Node.node_Nodes
  ptr LocalItem = LocalList.list_First
  i32 declCount = 0
  loop
    breakif not LocalItem
    i32 dataType = LocalItem.item_Object.node_type
    i32 count = 1
    loop
      ptr NextItem = LocalItem.item_Next
      breakif not NextItem
      breakif dataType <> NextItem.item_Object.node_type
      LocalItem = NextItem
      count = count + 1
    end
    appendUleb(Wasm, count)  // count
    if dataType == tokens_bool or dataType == tokens_ptr then
      appendByte(Wasm, tokens_i32)
    else
      appendByte(Wasm, dataType)
    end
    LocalItem = LocalItem.item_Next
    declCount = declCount + 1
  end
  emitNode(Node.node_ANode)  // Body block node
  appendByte(Wasm, 0x0b)  // end
  i32 length = Wasm.string_length - start
  i32 offset = uLebLength(length) - 1 + uLebLength(declCount) - 1
  offsetTail(Wasm, start, offset)
  Wasm.string_length = start - 1
  appendUleb(Wasm, length)
  appendUleb(Wasm, declCount)
  Wasm.string_length = Wasm.string_length + length - 1
end

func emitNode(ptr Node)
  i32 kind = Node.node_kind
  if kind == nodes_block then
    emitBlock(Node)
  elseif kind == nodes_assign then
    emitAssignment(Node, false)
  elseif kind == nodes_unary then
    emitUnary(Node)
  elseif kind == nodes_call then
    emitCall(Node)
  elseif kind == nodes_return then
    emitReturn(Node)
  elseif kind == nodes_if then
    emitIf(Node)
  elseif kind == nodes_breakif then
    emitBreakif(Node)
  elseif kind == nodes_drop then
    emitDrop(Node)
  elseif kind == nodes_loop then
    emitLoop(Node)
  elseif kind == nodes_hexwasm then
    appendByte(Wasm, Node.node_type)
  elseif kind == nodes_literal then
    emitLiteral(Node)
  elseif kind == nodes_identifier then
    emitIdentifier(Node)
  elseif kind == nodes_dotLoad then
    emitDotLoad(Node)
  elseif kind == nodes_dotStore then
    emitDotStore(Node)
  elseif kind == nodes_variable then
    emitVariable(Node)
  elseif kind == nodes_continue then
    appendByte(Wasm, 0x0c)  // br
    appendUleb(Wasm, scopeLevel(Node, nodes_loop))
  elseif kind == nodes_break then
    appendByte(Wasm, 0x0c)  // br
    appendUleb(Wasm, scopeLevel(Node, nodes_loop) + 1)
  else
    addError(error_emitNode, Node.node_Token)
  end
end

func emitExpression(ptr Node)
  i32 kind = Node.node_kind
  if kind == nodes_binary then
    emitBinary(Node)
  elseif kind == nodes_unary then
    emitUnary(Node)
  elseif kind == nodes_call then
    emitCall(Node)
  elseif kind == nodes_hexwasm then
    appendByte(Wasm, Node.node_type)
  elseif kind == nodes_literal then
    emitLiteral(Node)
  elseif kind == nodes_identifier then
    emitIdentifier(Node)
  elseif kind == nodes_dotLoad then
    emitDotLoad(Node)
  elseif kind == nodes_variable then
    emitVariable(Node)
  elseif kind == nodes_iif then
    emitIif(Node)
  else
    addError(error_expression, Node.node_Token)
  end
end

func emitAssignment(ptr Node, bool isExpression)
  ptr ResolvedNode = ScopeResolve(CurrentScope, Node.node_ANode.node_String, Node.node_Token)
  i32 dataType = ResolvedNode.node_type
  ptr BNode = Node.node_BNode
  Node.node_dataType = dataType
  if BNode.node_dataType <> 0 and BNode.node_dataType <> dataType then
    addError(error_typeMismatch, Node.node_Token)
  end
  BNode.node_dataType = dataType
  emitExpression(BNode)
  if ResolvedNode.node_Scope == GlobalScope then
    appendByte(Wasm, 0x24)  // set_global
    if isExpression then
      appendUleb(Wasm, ResolvedNode.node_index)
      appendByte(Wasm, 0x23)  // get_global
    end
  else
    if isExpression then
      appendByte(Wasm, 0x22)  // tee_local
    else
      appendByte(Wasm, 0x21)  // set_local
    end
  end
  appendUleb(Wasm, ResolvedNode.node_index)
end

func emitBinary(ptr Node)
  i32 type = Node.node_type
  if type == tokens_tee then
    emitAssignment(Node, true)
  else
    i32 dataType = Node.node_dataType
    ptr ANode = Node.node_ANode
    ptr BNode = Node.node_BNode
    if not dataType then
      dataType = inferDataType(Node)
      if not dataType then
        addError(error_typeNotInferred, Node.node_Token)
      end
      Node.node_dataType = dataType
    end
    ANode.node_dataType = dataType
    BNode.node_dataType = dataType
    emitExpression(ANode)
    emitExpression(BNode)
    emitOperator(type, dataType, Node)
  end
end

func emitOperator(i32 type, i32 dataType, ptr Node)
  if dataType == tokens_f64 then
    if     type == tokens_eq       then appendByte(Wasm, 0x61)
    elseif type == tokens_ne       then appendByte(Wasm, 0x62)
    elseif type == tokens_lt       then appendByte(Wasm, 0x63)
    elseif type == tokens_gt       then appendByte(Wasm, 0x64)
    elseif type == tokens_le       then appendByte(Wasm, 0x65)
    elseif type == tokens_ge       then appendByte(Wasm, 0x66)
    elseif type == tokens_abs      then appendByte(Wasm, 0x99)
    elseif type == tokens_neg      then appendByte(Wasm, 0x9a)
    elseif type == tokens_ceil     then appendByte(Wasm, 0x9b)
    elseif type == tokens_floor    then appendByte(Wasm, 0x9c)
    elseif type == tokens_trunc    then appendByte(Wasm, 0x9d)
    elseif type == tokens_round    then appendByte(Wasm, 0x9e)
    elseif type == tokens_sqrt     then appendByte(Wasm, 0x9f)
    elseif type == tokens_add      then appendByte(Wasm, 0xa0)
    elseif type == tokens_sub      then appendByte(Wasm, 0xa1)
    elseif type == tokens_mul      then appendByte(Wasm, 0xa2)
    elseif type == tokens_div      then appendByte(Wasm, 0xa3)
    elseif type == tokens_min      then appendByte(Wasm, 0xa4)
    elseif type == tokens_max      then appendByte(Wasm, 0xa5)
    elseif type == tokens_copysign then appendByte(Wasm, 0xa6) 
    else
      addError(error_invalidOperator, Node.node_Token)
    end
  elseif dataType == tokens_f32 then
    if     type == tokens_eq       then appendByte(Wasm, 0x5b)
    elseif type == tokens_ne       then appendByte(Wasm, 0x5c)
    elseif type == tokens_lt       then appendByte(Wasm, 0x5d)
    elseif type == tokens_gt       then appendByte(Wasm, 0x5e)
    elseif type == tokens_le       then appendByte(Wasm, 0x5f)
    elseif type == tokens_ge       then appendByte(Wasm, 0x60)
    elseif type == tokens_abs      then appendByte(Wasm, 0x8b)
    elseif type == tokens_neg      then appendByte(Wasm, 0x8c)
    elseif type == tokens_ceil     then appendByte(Wasm, 0x8d)
    elseif type == tokens_floor    then appendByte(Wasm, 0x8e)
    elseif type == tokens_trunc    then appendByte(Wasm, 0x8f)
    elseif type == tokens_round    then appendByte(Wasm, 0x90)
    elseif type == tokens_sqrt     then appendByte(Wasm, 0x91)
    elseif type == tokens_add      then appendByte(Wasm, 0x92)
    elseif type == tokens_sub      then appendByte(Wasm, 0x93)
    elseif type == tokens_mul      then appendByte(Wasm, 0x94)
    elseif type == tokens_div      then appendByte(Wasm, 0x95)
    elseif type == tokens_min      then appendByte(Wasm, 0x96)
    elseif type == tokens_max      then appendByte(Wasm, 0x97)
    elseif type == tokens_copysign then appendByte(Wasm, 0x98)
    else
      addError(error_invalidOperator, Node.node_Token)
    end
  elseif dataType == tokens_i64 then
    if     type == tokens_not  then appendByte(Wasm, 0x50)
    elseif type == tokens_eq   then appendByte(Wasm, 0x51)
    elseif type == tokens_ne   then appendByte(Wasm, 0x52)
    elseif type == tokens_lt   then appendByte(Wasm, 0x53)
    elseif type == tokens_ltu  then appendByte(Wasm, 0x54)
    elseif type == tokens_gt   then appendByte(Wasm, 0x55)
    elseif type == tokens_gtu  then appendByte(Wasm, 0x56)
    elseif type == tokens_le   then appendByte(Wasm, 0x57)
    elseif type == tokens_leu  then appendByte(Wasm, 0x58)
    elseif type == tokens_ge   then appendByte(Wasm, 0x59)
    elseif type == tokens_geu  then appendByte(Wasm, 0x5a)
    elseif type == tokens_clz  then appendByte(Wasm, 0x79)
    elseif type == tokens_ctz  then appendByte(Wasm, 0x7a)
    elseif type == tokens_cnt  then appendByte(Wasm, 0x7b)
    elseif type == tokens_add  then appendByte(Wasm, 0x7c)
    elseif type == tokens_sub  then appendByte(Wasm, 0x7d)
    elseif type == tokens_mul  then appendByte(Wasm, 0x7e)
    elseif type == tokens_div  then appendByte(Wasm, 0x7f)
    elseif type == tokens_divu then appendByte(Wasm, 0x80)
    elseif type == tokens_mod  then appendByte(Wasm, 0x81)
    elseif type == tokens_modu then appendByte(Wasm, 0x82)
    elseif type == tokens_and  then appendByte(Wasm, 0x83)
    elseif type == tokens_or   then appendByte(Wasm, 0x84)
    elseif type == tokens_xor  then appendByte(Wasm, 0x85)
    elseif type == tokens_shl  then appendByte(Wasm, 0x86)
    elseif type == tokens_shr  then appendByte(Wasm, 0x87)
    elseif type == tokens_shru then appendByte(Wasm, 0x88)
    elseif type == tokens_rotl then appendByte(Wasm, 0x89)
    elseif type == tokens_rotr then appendByte(Wasm, 0x8a)
    else
      addError(error_invalidOperator, Node.node_Token)
    end
  else
    if     type == tokens_not  then appendByte(Wasm, 0x45)
    elseif type == tokens_eq   then appendByte(Wasm, 0x46)
    elseif type == tokens_ne   then appendByte(Wasm, 0x47)
    elseif type == tokens_lt   then appendByte(Wasm, 0x48)
    elseif type == tokens_ltu  then appendByte(Wasm, 0x49)
    elseif type == tokens_gt   then appendByte(Wasm, 0x4a)
    elseif type == tokens_gtu  then appendByte(Wasm, 0x4b)
    elseif type == tokens_le   then appendByte(Wasm, 0x4c)
    elseif type == tokens_leu  then appendByte(Wasm, 0x4d)
    elseif type == tokens_ge   then appendByte(Wasm, 0x4e)
    elseif type == tokens_geu  then appendByte(Wasm, 0x4f)
    elseif type == tokens_clz  then appendByte(Wasm, 0x67)
    elseif type == tokens_ctz  then appendByte(Wasm, 0x68)
    elseif type == tokens_cnt  then appendByte(Wasm, 0x69)
    elseif type == tokens_add  then appendByte(Wasm, 0x6a)
    elseif type == tokens_sub  then appendByte(Wasm, 0x6b)
    elseif type == tokens_mul  then appendByte(Wasm, 0x6c)
    elseif type == tokens_div  then appendByte(Wasm, 0x6d)
    elseif type == tokens_divu then appendByte(Wasm, 0x6e)
    elseif type == tokens_mod  then appendByte(Wasm, 0x6f)
    elseif type == tokens_modu then appendByte(Wasm, 0x70)
    elseif type == tokens_and  then appendByte(Wasm, 0x71)
    elseif type == tokens_or   then appendByte(Wasm, 0x72)
    elseif type == tokens_xor  then appendByte(Wasm, 0x73)
    elseif type == tokens_shl  then appendByte(Wasm, 0x74)
    elseif type == tokens_shr  then appendByte(Wasm, 0x75)
    elseif type == tokens_shru then appendByte(Wasm, 0x76)
    elseif type == tokens_rotl then appendByte(Wasm, 0x77)
    elseif type == tokens_rotr then appendByte(Wasm, 0x78)
    else
      addError(error_invalidOperator, Node.node_Token)
    end
  end
end

func emitUnary(ptr Node)
  i32 type = Node.node_type
  i32 dataType = Node.node_dataType
  if type == tokens_sub then
    if dataType == tokens_f64 then
      appendByte(Wasm, 0x44)  // f64.const
      appendF64(Wasm, 0) 
    elseif dataType == tokens_f32 then
      appendByte(Wasm, 0x43)  // f32.const
      appendF32(Wasm, 0) 
    elseif dataType == tokens_i64 then
      appendByte(Wasm, 0x42)  // i64.const 
      appendByte(Wasm, 0x00)  // 0
    else
      appendByte(Wasm, 0x41)  // i32.const 
      appendByte(Wasm, 0x00)  // 0
    end
  end
  emitExpression(Node.node_BNode)
  emitOperator(type, dataType, Node)
end

func emitIdentifier(ptr Node)
  ptr ResolvedNode = ScopeResolve(CurrentScope, Node.node_String, Node.node_Token)
  i32 dataType = ResolvedNode.node_dataType
  i32 nodeDataType = Node.node_dataType
  if dataType == tokens_bool or dataType == tokens_ptr then
    dataType = tokens_i32
  end
  if nodeDataType == tokens_bool or nodeDataType == tokens_ptr then
    nodeDataType = tokens_i32
  end
  if nodeDataType <> 0 and nodeDataType <> dataType then
    addError(error_typeMismatch, Node.node_Token)
  end
  Node.node_dataType = dataType
  if ResolvedNode.node_Scope == GlobalScope then
    appendByte(Wasm, 0x23)  // get_global
  else
    appendByte(Wasm, 0x20)  // get_local
  end
  appendUleb(Wasm, ResolvedNode.node_index)
end

// A.B.C.D
// loadX(load(load(A + B) + C) + D)
// A B + load() C + load() D + loadX()
func emitDotLoad(ptr Node)
  i32 dataType = Node.node_dataType
  ptr IdentList = Node.node_Nodes
  i32 Item = IdentList.list_First
  i32 itemCount = IdentList.list_count
  i32 itemNo = 1
  emitIdentifier(Item.item_Object)
  Item = Item.item_Next
  loop
    breakif not Item
    itemNo = itemNo + 1
    emitIdentifier(Item.item_Object)
    appendByte(Wasm, 0x6a)  // i32.add
    if itemNo < itemCount then
      appendByte(Wasm, 0x28)  // i32.load
    else
      if not dataType then
        addError(error_typeNotInferred, Node.node_Token)
      end
      if dataType == tokens_f64 then
        appendByte(Wasm, 0x2b)  // f64.load
      elseif dataType == tokens_f32 then
        appendByte(Wasm, 0x2a)  // f32.load
      elseif dataType == tokens_i64 then
        appendByte(Wasm, 0x29)  // i64.load
      else
        appendByte(Wasm, 0x28)  // i32.load
      end
    end
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
    Item = Item.item_Next
  end
end

// A.B.C.D = x
// storeX(load(load(A + B) + C) + D, x)
// A B + load() C + load() D + x storeX()
func emitDotStore(ptr Node)
  i32 dataType = Node.node_dataType
  if not dataType then
    dataType = inferDataType(Node.node_ANode)
    Node.node_dataType = dataType
  end
  ptr IdentList = Node.node_Nodes
  i32 Item = IdentList.list_First
  i32 itemCount = IdentList.list_count
  i32 itemNo = 1
  emitIdentifier(Item.item_Object)
  Item = Item.item_Next
  loop
    breakif not Item
    itemNo = itemNo + 1
    emitIdentifier(Item.item_Object)
    appendByte(Wasm, 0x6a)  // i32.add
    if itemNo < itemCount then
      appendByte(Wasm, 0x28)  // i32.load
    else
      emitExpression(Node.node_ANode)
      if dataType == tokens_f64 then
        appendByte(Wasm, 0x39)  // f64.store
      elseif dataType == tokens_f32 then
        appendByte(Wasm, 0x38)  // f32.store
      elseif dataType == tokens_i64 then
        appendByte(Wasm, 0x37)  // i64.store
      else
        appendByte(Wasm, 0x36)  // i32.store
      end
    end
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
    Item = Item.item_Next
  end
end

func emitNumLiteral(ptr Node, i32 dataType)
  if dataType == tokens_f64 then
    appendByte(Wasm, 0x44)  // f64.const
    appendF64(Wasm, strToF64(Node.node_String))
  elseif dataType == tokens_f32 then
    appendByte(Wasm, 0x43)  // f32.const
    appendF32(Wasm, strToF32(Node.node_String))
  elseif dataType == tokens_i64 then
    appendByte(Wasm, 0x42)  // i64.const
    appendSleb64(Wasm, strToI64(Node.node_String, Node.node_Token))
  else
    appendByte(Wasm, 0x41)  // i32.const
    appendSleb32(Wasm, strToI32(Node.node_String, Node.node_Token))
  end
end

func emitCharLiteral(ptr Node, i32 dataType)
  ptr Name = Node.node_String
  if dataType == tokens_i64 then
    appendByte(Wasm, 0x42)  // i64.const
    if Name.string_length.i32 > 4 then
      appendSleb64(Wasm, load64(Name + string_Chars))
    else
      appendSleb32(Wasm, Name.string_Chars)
    end
  else
    appendByte(Wasm, 0x41)  // i32.const
    appendSleb32(Wasm, Name.string_Chars)
  end
end

func emitLiteral(ptr Node)
  i32 type = Node.node_type
  i32 dataType = Node.node_dataType
  if type == tokens_numLiteral then
    emitNumLiteral(Node, dataType)
  elseif type == tokens_charLiteral then
    emitCharLiteral(Node, dataType)
  elseif type == tokens_true then
    appendByte(Wasm, 0x41)  // i32.const
    appendByte(Wasm, 0x01)  // 1
  elseif type == tokens_false then
    appendByte(Wasm, 0x41)  // i32.const
    appendByte(Wasm, 0x00)  // 0
  end
end

func emitFunCallArguments(ptr CallNode, ptr FunNode)
  ptr ArgumentList = CallNode.node_ParamNodes
  ptr ArgumentItem = ArgumentList.list_First
  ptr ParamList = FunNode.node_ParamNodes
  ptr ParamItem = ParamList.list_First
  loop
    breakif not ArgumentItem
    ptr ArgumentNode = ArgumentItem.item_Object
    ptr ParamNode = ParamItem.item_Object
    ArgumentNode.node_dataType.i32 = ParamNode.node_dataType
    emitExpression(ArgumentNode)
    ArgumentItem = ArgumentItem.item_Next
    ParamItem = ParamItem.item_Next
  end
end

func emitCallArguments(ptr CallNode, i32 data_Type)
  ptr ArgumentList = CallNode.node_ParamNodes
  ptr ArgumentItem = ArgumentList.list_First
  loop
    breakif not ArgumentItem
    ptr ArgumentNode = ArgumentItem.item_Object
    ArgumentNode.node_dataType = data_Type
    emitExpression(ArgumentNode)
    ArgumentItem = ArgumentItem.item_Next
  end
end

func emitCallArguments2(ptr CallNode, i32 data_TypeA, i32 data_TypeB)
  ptr ArgumentList = CallNode.node_ParamNodes
  ptr ArgumentItem = ArgumentList.list_First
  bool isFirst = true
  loop
    breakif not ArgumentItem
    ptr ArgumentNode = ArgumentItem.item_Object
    if isFirst then
      ArgumentNode.node_dataType = data_TypeA
    else    
      ArgumentNode.node_dataType = data_TypeB
    end
    emitExpression(ArgumentNode)
    ArgumentItem = ArgumentItem.item_Next
    isFirst = false
  end
end

func emitCall(ptr Node)
  ptr Name = Node.node_ANode.node_String
  if strEqChar(Name, 'i64_i32') then
    emitCallArguments(Node, tokens_i64)
    appendByte(Wasm, 0xa7)  // i32.wrap/i64
  elseif strEqChar(Name, 'f32_i32') then
    emitCallArguments(Node, tokens_f32)
    appendByte(Wasm, 0xa8)  // i32.trunc_s/f32
  elseif strEqChar(Name, 'f32_i32u') then
    emitCallArguments(Node, tokens_f32)
    appendByte(Wasm, 0xa9)  // i32.trunc_u/f32
  elseif strEqChar(Name, 'f64_i32') then
    emitCallArguments(Node, tokens_f64)
    appendByte(Wasm, 0xaa)  // i32.trunc_s/f64
  elseif strEqChar(Name, 'f64_i32u') then
    emitCallArguments(Node, tokens_f64)
    appendByte(Wasm, 0xab)  // i32.trunc_u/f64
  elseif strEqChar(Name, 'i32_i64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0xac)  // i64.extend_s/i32
  elseif strEqChar(Name, 'i32_i64u') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0xad)  // i64.extend_u/i32
  elseif strEqChar(Name, 'f32_i64') then
    emitCallArguments(Node, tokens_f32)
    appendByte(Wasm, 0xae)  // i64.trunc_s/f32
  elseif strEqChar(Name, 'f32_i64u') then
    emitCallArguments(Node, tokens_f32)
    appendByte(Wasm, 0xaf)  // i64.trunc_u/f32
  elseif strEqChar(Name, 'f64_i64') then
    emitCallArguments(Node, tokens_f64)
    appendByte(Wasm, 0xb0)  // i64.trunc_s/f64
  elseif strEqChar(Name, 'f64_i64u') then
    emitCallArguments(Node, tokens_f64)
    appendByte(Wasm, 0xb1)  // i64.trunc_u/f64
  elseif strEqChar(Name, 'i32_f32') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0xb2)  // f32.convert_s/i32    
  elseif strEqChar(Name, 'i32_f32u') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0xb3)  // f32.convert_u/i32   
  elseif strEqChar(Name, 'i64_f32') then
    emitCallArguments(Node, tokens_i64)
    appendByte(Wasm, 0xb4)  // f32.convert_s/i64
  elseif strEqChar(Name, 'i64_f32u') then
    emitCallArguments(Node, tokens_i64)
    appendByte(Wasm, 0xb5)  // f32.convert_u/i64
  elseif strEqChar(Name, 'f64_f32') then
    emitCallArguments(Node, tokens_f64)
    appendByte(Wasm, 0xb6)  // f32.demote/f64
  elseif strEqChar(Name, 'i32_f64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0xb7)  // f64.convert_s/i32
  elseif strEqChar(Name, 'i32_f64u') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0xb8)  // f64.convert_u/i32
  elseif strEqChar(Name, 'i64_f64') then
    emitCallArguments(Node, tokens_i64)
    appendByte(Wasm, 0xb9)  // f64.convert_s/i64
  elseif strEqChar(Name, 'i64_f64u') then
    emitCallArguments(Node, tokens_i64)
    appendByte(Wasm, 0xba)  // f64.convert_u/i64
  elseif strEqChar(Name, 'f32_f64') then
    emitCallArguments(Node, tokens_f32)
    appendByte(Wasm, 0xbb)  // f64.promote/f32
  elseif strEqChar(Name, 'load32') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x28)  // i32.load
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'load64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x29)  // i64.load
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'loadf32') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x2a)  // f32.load
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'loadf64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x2b)  // f64.load
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'load8') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x2c)  // i32.load8_s
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'load8u') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x2d)  // i32.load8_u
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'load16') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x2e)  // i32.load16_s
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'load16u') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x2f)  // i32.load16_u
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'loa8i64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x30)  // i64.load8_s
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'loa8u64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x31)  // i64.load8_u
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'loa16i64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x32)  // i64.load16_s
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset    
  elseif strEqChar(Name, 'loa16u64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x33)  // i64.load16_u
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset 
  elseif strEqChar(Name, 'loa32i64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x34)  // i64.load32_s
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset    
  elseif strEqChar(Name, 'loa32u64') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x35)  // i64.load32_u
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset    
  elseif strEqChar(Name, 'store32') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x36)  // i32.store
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'store64') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    appendByte(Wasm, 0x37)  // i64.store
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'storeF32') then
    emitCallArguments2(Node, tokens_i32, tokens_f32)
    appendByte(Wasm, 0x38)  // f32.store
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'storeF64') then
    emitCallArguments2(Node, tokens_i32, tokens_f64)
    appendByte(Wasm, 0x39)  // f64.store
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'store8') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x3a)  // i32.store8
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'store16') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x3b)  // i32.store16
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'i64sto8') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    appendByte(Wasm, 0x3c)  // i64.store8
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'i64sto16') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    appendByte(Wasm, 0x3d)  // i64.store16
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'i64sto32') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    appendByte(Wasm, 0x3e)  // i64.store32
    appendByte(Wasm, 0x00)  // alignment
    appendByte(Wasm, 0x00)  // offset
  elseif strEqChar(Name, 'memsize') then
    appendByte(Wasm, 0x3f)  // current_memory
    appendByte(Wasm, 0x00)  // memory number
  elseif strEqChar(Name, 'memgrow') then
    emitCallArguments(Node, tokens_i32)
    appendByte(Wasm, 0x40)  // grow_memory
    appendByte(Wasm, 0x00)  // memory number
  else
    ptr ResolvedNode = ScopeResolve(CurrentScope, Name, Node.node_Token)
    if ResolvedNode then
      emitFunCallArguments(Node, ResolvedNode)
      appendByte(Wasm, 0x10)  // call
      appendUleb(Wasm, ResolvedNode.node_index)
    end
  end
end

func emitBlock(ptr Node)
  ptr Scope = Node.node_Scope
  CurrentScope = Scope
  ptr BlockList = Node.node_Nodes
  ptr Item = BlockList.list_First
  loop
    breakif not Item
    emitNode(Item.item_Object)
    Item = Item.item_Next
  end
  CurrentScope = Scope.scope_Parent
end

func emitIf(ptr Node)
  emitExpression(Node.node_CNode)  // If condition expression
  appendByte(Wasm, 0x04)  // if
  appendByte(Wasm, 0x40)  // void
  emitNode(Node.node_ANode)  // Then block
  ptr ElseBlock = Node.node_BNode
  if ElseBlock then
    appendByte(Wasm, 0x05)  // else
    emitNode(ElseBlock)
  end
  appendByte(Wasm, 0x0b)  // end
end

func i32 scopeLevel(ptr Node, i32 kind) 
  ptr Scope = Node.node_Scope
  i32 level = 0
  loop
    breakif not Scope
    breakif Scope.scope_Node.node_kind == kind
    level = level + 1
    Scope = Scope.scope_Parent
  end
  return level
end

func emitLoop(ptr Node)
  appendByte(Wasm, 0x02)  // block
  appendByte(Wasm, 0x40)  // void 
  appendByte(Wasm, 0x03)  // loop
  appendByte(Wasm, 0x40)  // void 
  emitNode(Node.node_ANode)
  appendByte(Wasm, 0x0c)  // br
  appendByte(Wasm, 0x00)  // level 
  appendByte(Wasm, 0x0b)  // end
  appendByte(Wasm, 0x0b)  // end
end

func i32 inferCallDataType(ptr Node)
  ptr Name = Node.node_String
  if     strEqChar(Name, 'load64')   then return tokens_i64
  elseif strEqChar(Name, 'load32')   then return tokens_i32
  elseif strEqChar(Name, 'load8')    then return tokens_i32
  elseif strEqChar(Name, 'load8u')   then return tokens_i32
  elseif strEqChar(Name, 'memsize')  then return tokens_i32
  elseif strEqChar(Name, 'loa_f32')  then return tokens_f32
  elseif strEqChar(Name, 'loa_f64')  then return tokens_f64
  elseif strEqChar(Name, 'f32_i32')  then return tokens_i32
  elseif strEqChar(Name, 'f32_i32u') then return tokens_i32
  elseif strEqChar(Name, 'f64_i32')  then return tokens_i32
  elseif strEqChar(Name, 'f64_i32u') then return tokens_i32
  elseif strEqChar(Name, 'i32_i64')  then return tokens_i64
  elseif strEqChar(Name, 'i32_i64u') then return tokens_i64
  elseif strEqChar(Name, 'f32_i64')  then return tokens_i64
  elseif strEqChar(Name, 'f32_i64u') then return tokens_i64
  elseif strEqChar(Name, 'f64_i64')  then return tokens_i64
  elseif strEqChar(Name, 'f64_i64u') then return tokens_i64
  elseif strEqChar(Name, 'i32_f32')  then return tokens_f32
  elseif strEqChar(Name, 'i32_f32u') then return tokens_f32
  elseif strEqChar(Name, 'i64_f32')  then return tokens_f32
  elseif strEqChar(Name, 'i64_f32u') then return tokens_f32
  elseif strEqChar(Name, 'f64_f32')  then return tokens_f32
  elseif strEqChar(Name, 'i32_f64')  then return tokens_f64
  elseif strEqChar(Name, 'i32_f64u') then return tokens_f64
  elseif strEqChar(Name, 'i64_f64')  then return tokens_f64
  elseif strEqChar(Name, 'i64_f64u') then return tokens_f64
  elseif strEqChar(Name, 'f32_f64')  then return tokens_f64
  else
    ptr ResolvedNode = ScopeResolve(CurrentScope, Name, Node.node_Token)
    return ResolvedNode.node_dataType
  end
  return 0
end

func i32 inferDataType(ptr Node)
  i32 dataType = Node.node_dataType
  i32 kind = Node.node_kind
  if kind == nodes_binary or kind == nodes_iif or kind == nodes_assign then
    if not (dataType := inferDataType(Node.node_ANode)) then
      dataType = inferDataType(Node.node_BNode)
    end
  elseif kind == nodes_identifier then
    ptr ResolvedNode = ScopeResolve(CurrentScope, Node.node_String, Node.node_Token)
    dataType = ResolvedNode.node_dataType
  elseif kind == nodes_unary then
    dataType = inferDataType(Node.node_BNode)
  elseif kind == nodes_call then
    dataType = inferCallDataType(Node.node_ANode)
  end
  return dataType
end

func emitIif(ptr Node)
  i32 dataType = Node.node_dataType
  ptr ANode = Node.node_ANode
  ptr BNode = Node.node_BNode
  ptr CNode = Node.node_CNode
  if not dataType then
    if not (dataType := inferDataType(Node)) then
      addError(error_typeNotInferred, Node.node_Token)
    end
    Node.node_dataType = dataType
  end
  ANode.node_dataType = dataType
  BNode.node_dataType = dataType
  emitExpression(ANode)
  emitExpression(BNode)
  emitExpression(CNode)
  appendByte(Wasm, 0x1b)  // select
end

func emitVariable(ptr Node)
  i32 type = Node.node_type
  ptr BNode = Node.node_BNode
  BNode.node_dataType = type
  emitExpression(BNode)
  appendByte(Wasm, 0x21)  // set_local
  appendUleb(Wasm, Node.node_index)
end

func emitReturn(ptr Node)
  ptr ANode = Node.node_ANode
  i32 dataType = CurrentFunNode.node_dataType
  if dataType then
    Node.node_dataType = dataType
    ANode.node_dataType = dataType
    emitExpression(ANode)
  end
  if scopeLevel(Node, nodes_fun) > 0 then
    appendByte(Wasm, 0x0f)  // return
  end
end

func emitBreakif(ptr Node)
  emitExpression(Node.node_CNode)  // If condition expression
  appendByte(Wasm, 0x0d)  // br_if
  appendUleb(Wasm, scopeLevel(Node, nodes_loop) + 1)
end

func emitDrop(ptr Node)
  emitExpression(Node.node_CNode)
  appendByte(Wasm, 0x1a)  // drop
end

func emitDataSection()
  i32 count = DataList.list_count
  if count then
    appendByte(Wasm, 0x0b)  // Data section
    appendByte(Wasm, 0x00)  // Section size (guess)
    i32 start = Wasm.string_length 
    appendUleb(Wasm, count)
    ptr DataItem = DataList.list_First
    loop
      appendByte(Wasm, 0x00)  // memory index 
      appendByte(Wasm, 0x41)  // i32.const
      appendUleb(Wasm, strToI32(DataItem.item_Object.token_Value, DataItem.item_Object))  // offset
      appendByte(Wasm, 0x0b)  // end
      ptr DataString = DataItem.item_Name.token_Value
      i32 dataLength = DataString.string_length
      appendUleb(Wasm, dataLength)
      appendString(Wasm, DataString)
      breakif not (DataItem := DataItem.item_Next)
    end
    i32 length = Wasm.string_length - start
    i32 offset = uLebLength(length) - 1
    offsetTail(Wasm, start, offset)
    Wasm.string_length = start - 1
    appendUleb(Wasm, length)
    Wasm.string_length = Wasm.string_length + length
  end
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Errors

i32 error_duplicateName   = 1
i32 error_invalidToken    = 2
i32 error_missingToken    = 3
i32 error_expression      = 4
i32 error_typeMismatch    = 5
i32 error_rootStatement   = 6
i32 error_typeNotInferred = 7
i32 error_notDeclared     = 8
i32 error_literalToInt    = 9
i32 error_blockStatement  = 10
i32 error_emitNode        = 11
i32 error_invalidOperator = 12

func addError(i32 errorNo, ptr Token)
  listAddName(Errors, Token, errorNo)
end

func parseErrorList()
  ptr ErrorItem = Errors.list_First
  if ErrorItem then
    ptr ErrorString = NewEmptyString(1000)
    loop
      ptr Token = ErrorItem.item_Object
      i32 errorNo = ErrorItem.item_number
      if errorNo == error_duplicateName then
        appendChar3(ErrorString, 'Duplicat', 'e identi', 'fier')
      elseif errorNo == error_invalidToken then
        appendChar2(ErrorString, 'Invalid ', 'token')
      elseif errorNo == error_missingToken then
        appendChar2(ErrorString, 'Missing ', 'token')
      elseif errorNo == error_rootStatement then
        appendChar3(ErrorString, 'Invalid ', 'root sta', 'tement')
      elseif errorNo == error_blockStatement then
        appendChar3(ErrorString, 'Invalid ', 'block st', 'atement')
      elseif errorNo == error_typeMismatch then
        appendChar2(ErrorString, 'Type mis', 'match')
      elseif errorNo == error_notDeclared then
        appendChar3(ErrorString, 'Identifi', 'er not d', 'eclared')
      elseif errorNo == error_literalToInt then
        appendChar3(ErrorString, 'Could no', 't conver', 't to int')
      elseif errorNo == error_expression then
        appendChar3(ErrorString, 'Expressi', 'on expec', 'ted')
      elseif errorNo == error_typeNotInferred then
        appendChar3(ErrorString, 'Could no', 't determ', 'ine type')
      elseif errorNo == error_emitNode then
        appendChar3(ErrorString, 'Unexpect', 'ed node ', 'type')
      elseif errorNo == error_invalidOperator then
        appendChar2(ErrorString, 'Invalid ', 'operator')
      else  
        appendChar(ErrorString, 'Error ')
        appendIntToStr(ErrorString, errorNo)
      end
      if Token then
        appendChar(ErrorString, ' line ')
        appendIntToStr(ErrorString, Token.token_line)
        appendChar(ErrorString, ' column ')
        if Token.token_Value.i32 then
          appendIntToStr(ErrorString, Token.token_column - Token.token_Value.string_length)
          appendChar(ErrorString, ' token ')
          appendString(ErrorString, Token.token_Value)
        else
          appendIntToStr(ErrorString, Token.token_column)
        end
        appendChar(ErrorString, 13)
      end
      Wasm = ErrorString
      breakif not (ErrorItem := ErrorItem.item_Next)
    end
  end
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Function library

func i32 strToI32(ptr String, ptr Token)
  return i64_i32(strToI64(String, Token))
end

func i64 strToI64(ptr String, ptr Token)  // Supports ints and 0x-prefixed hex
  bool isHex = false
  i64 i = 0
  i32 length = String.string_length
  i32 offset = 0
  i32 chr = 0
  if length >= 3 then
    if getChar(String, 0) == '0' and getChar(String, 1) == 'x' then
      isHex = true
    end
  end
  if isHex then
    offset = 2
    loop
      breakif offset >= length
      i = i * 16
      chr = getChar(String, offset)
      if chr >= '0' and chr <= '9' then
        i = i + i32_i64(chr) - '0'
      elseif chr >= 'a' and chr <= 'f' then
        i = i + i32_i64(chr) - 'a' + 10
      elseif chr >= 'A' and chr <= 'F' then
        i = i + i32_i64(chr) - 'A' + 10
      else
        addError(error_literalToInt, Token)
      end
      offset = offset + 1
    end
  else
    loop
      breakif offset >= length
      i = i * 10
      chr = getChar(String, offset)
      if chr >= '0' and chr <= '9' then
        i = i + i32_i64(chr) - '0'
      elseif offset == 0 and chr == '-' then
      else
        addError(error_literalToInt, Token)
      end
      offset = offset + 1
    end
  end
  if getChar(String, 0) == '-' then i = -i end
  return i
end

func f32 strToF32(ptr String)
  return f64_f32(strToF64(String))
end

func f64 strToF64(ptr String)
  f64 f = f
  i32 length = String.string_length
  i32 offset = 0
  f64 d = 1
  bool isAfterDot = false
  loop
    breakif offset >= length
    i32 chr = getChar(String, offset)
    if chr == '.' then
      isAfterDot = true
    else
      if isAfterDot then 
        f = f + i32_f64(chr - '0') / d
        d = d * 10
      else
        if chr >= '0' and chr <= '9' then
          f = f * 10 + i32_f64(chr - '0')
        end
      end
    end
    offset = offset + 1
  end
  if getChar(String, 0) == '-' then f = -f end
  return f
end

func i32 uLebLength(i32 i)
  return iif i >+ 268435456 then 
    5
  else 
    iif i >+ 2097151 then 
      4 
    else
      iif i >+ 16383 then 
        3 
      else
        iif i >+ 127 then 
          2 
        else 
          1 
        end 
      end
    end 
  end
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Strings

// Structs
i32 string_dec0de = 0
i32 string_max    = 4
i32 string_length = 8
i32 string_Chars  = 12
i32 string_size   = 12

// Pascal-style strings: We store the length instead of using a null terminator
func i32 NewString(i32 length)
  i32 String = Alloc(string_size + length)
  String.string_dec0de = 7 - DEC0DE
  String.string_max = length
  String.string_length = length
  return String
end

func i32 NewEmptyString(i32 maxLength)
  i32 String = Alloc(string_size + maxLength)
  String.string_dec0de = 7 - DEC0DE
  String.string_max = maxLength
  String.string_length = 0
  return String
end

func appendString(ptr String, ptr AppendString)
  i32 appendLength = AppendString.string_length
  i32 maxLength = String.string_max
  i32 offset = 0
  loop
    breakif offset >= appendLength
    appendByte(String, getChar(AppendString, offset))
    breakif String.string_length >= maxLength
    offset = offset + 1
  end
end

func appendIntToStr(ptr String, i32 i)
  i32 length = String.string_length
  i32 appendLength = decimalStringLength(i)
  i32 offset = appendLength
  if length + appendLength <= String.string_max then
    loop
      i32 chr = '0' + i mod 10
      offset = offset - 1
      setChar(String, length + offset, chr)
      i = i / 10
      breakif not i
      breakif not offset 
    end  
    String.string_length = length + appendLength
  end
end

func appendI32(ptr String, i32 i)
  i32 length = String.string_length
  if length + 4 <= String.string_max then
    store32(String + string_Chars + length, i)
    String.string_length = length + 4
  end
end

func appendF32(ptr String, f32 f)
  i32 length = String.string_length
  if length + 4 <= String.string_max then
    storeF32(String + string_Chars + String.string_length, f)
    String.string_length = length + 4
  end
end

func appendF64(ptr String, f64 f)
  i32 length = String.string_length
  if length + 8 <= String.string_max then
    storeF64(String + string_Chars + length, f)
    String.string_length = length + 8
  end
end

func appendByte(ptr String, i32 i)
  i32 length = String.string_length
  if length + 1 <= String.string_max then
    store8(String + string_Chars + length, i)
    String.string_length = length + 1
  end
end

func appendChar(ptr String, i64 i)
  loop
    i32 chr = i64_i32(i mod 256)
    appendByte(String, chr)
    i = i >>+ 8
    breakif i == 0
  end
end

func appendChar2(ptr String, i64 i, i64 j)
  appendChar(String, i)
  appendChar(String, j)
end

func appendChar3(ptr String, i64 i, i64 j, i64 k)
  appendChar(String, i)
  appendChar(String, j)
  appendChar(String, k)
end

func appendUleb(ptr String, i32 i)
  i32 length = String.string_length
  if length + uLebLength(i) <= String.string_max then
    loop
      breakif i < 128
      i32 chr = 128 + (i mod 128)
      appendByte(String, chr)
      i = i >>+ 7
    end
    appendByte(String, i)
  end
end

func appendSleb32(ptr String, i32 i)
  appendSleb64(String, i32_i64(i))
end

func appendSleb64(ptr String, i64 i)
  if i >= 0 then 
    loop
      breakif i < 64
      appendByte(String, i64_i32(128 + (i mod 128)))
      i = i >> 7
    end
    appendByte(String, i64_i32(i))
  else
    loop
      breakif i >= -64
      appendByte(String, i64_i32((i modu 128) - 128))
      i = i >> 7
    end
    appendByte(String, i64_i32(i - 128))
  end
end

func offsetTail(ptr String, ptr start, i32 offset)
  if offset > 0 then
    if String.string_length + offset <= String.string_max then
      String.string_length = String.string_length + offset
      i32 copy = String.string_length
      loop
        breakif copy < start
        setChar(String, copy + offset, getChar(String, copy))
        copy = copy - 1
      end
    end
  end
end

func i32 decimalStringLength(i32 i)
  i32 length = 1
  loop
    i = i / 10
    breakif not i
    length = length + 1
  end
  return length
end

func i32 getChar(i32 String, i32 offset)
  return load8u(String + string_Chars + offset)
end

func setChar(i32 String, i32 offset, i32 chr)
  store8(String + string_Chars + offset, chr)
end

func i32 Substring(i32 String, i32 offset, i32 length)
  if offset >= String.string_length then
    length = 0
  end
  if offset + length >= String.string_length then
    length = String.string_length - offset
  end
  i32 R = NewString(length)
  loop
    breakif length == 0
    length = length - 1
    if offset + length >= 0 then
      setChar(R, length, getChar(String, offset + length))
    end
  end
  return R
end

func bool strEq(i32 A, i32 B)
  i32 length = A.string_length
  if length == B.string_length then
    i32 offset = 0
    loop
      if getChar(A, offset) <> getChar(B, offset) then
        return false
      end
      breakif offset >= length
      offset = offset + 1
    end
  else
    return false
  end
  return true
end

func bool strEqChar(i32 String, i64 a)
  i32 length = String.string_length
  if length > 8 then
    return false
  elseif length > 4 then
    if a <> load64(String + string_Chars) then return false end
  elseif length > 0 then
    if a <> i32_i64(load32(String + string_Chars)) then return false end
  else
    if a <> 0 then return false end
  end
  return true
end

func bool strEqChar2(i32 String, i64 a, i64 b)
  i32 length = String.string_length
  if length > 16 then
    return false
  elseif length > 12 then
    if a <> load64(String + string_Chars) then return false end
    if b <> load64(String + string_Chars + 8) then return false end
  elseif length > 8 then
    if a <> load64(String + string_Chars) then return false end
    if b <> i32_i64(load32(String + string_Chars + 8)) then return false end
  elseif length > 4 then
    if a <> load64(String + string_Chars) then return false end
    if b <> 0 then return false end
  elseif length > 0 then
    if a <> i32_i64(load32(String + string_Chars)) then return false end
    if b <> 0 then return false end
  else
    if a <> 0 then return false end
    if b <> 0 then return false end
  end
  return true
end

func i32 hexCharToInt(i32 char)
  if char >= '0' and char <= '9' then
    return char - '0'
  elseif char >= 'a' and char <= 'f' then
    return char - 'a' + 10
  elseif char >= 'A' and char <= 'F' then
    return char - 'A' + 10
  end
  return 0
end

// Strings may contain escaped hex bytes for example "\5a" -> "Z"
func decodeString(i32 S)
  i32 length = S.string_length
  i32 i = 0
  i32 o = 0
  loop
    breakif i >= length
    if getChar(S, i) == 92 then // backslash
      i = i + 1
      if isNumber(getChar(S, i), true) and isNumber(getChar(S, i + 1), true) then
        i32 char = hexCharToInt(getChar(S, i)) 
        char = char * 16
        char = char + hexCharToInt(getChar(S, i + 1))
        setChar(S, o, char)
        i = i + 1
      end
    elseif i > o then
      setChar(S, o, getChar(S, i))
    end
    i = i + 1
    o = o + 1
  end
  S.string_length = o
  loop
    breakif o >= length
    setChar(S, o, 0)
    o = o + 1
  end
end

func bool isAlpha(i32 chr)
  return (chr >= 'a' and chr <= 'z') or (chr >= 'A' and chr <= 'Z') or (chr == '_')
end

func bool isNumber(i32 chr, bool hexNum)
  if chr >= '0' and chr <= '9' then
    return true
  elseif hexNum then
    if (chr >= 'a' and chr <= 'f') or (chr >= 'A' and chr <= 'F') then 
      return true 
    end
  end
  return false
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Lists

i32 list_dec0de = 0  // debugging marker
i32 list_First  = 4
i32 list_Last   = 8
i32 list_count  = 12
i32 list_size   = 16

i32 item_dec0de = 0  // debugging marker
i32 item_Next   = 4
i32 item_Object = 8
i32 item_Name   = 12   i32 item_number = 12
i32 item_size   = 16

func ptr NewList()
  ptr List = Alloc(list_size)
  List.list_dec0de = 4 - DEC0DE
  return List
end

func listAdd(i32 List, i32 Object)
  i32 Item = Alloc(item_size)
  Item.item_dec0de = 5 - DEC0DE
  Item.item_Object = Object
  if not List.list_First.ptr then
    List.list_First = Item
  else
    List.list_Last.item_Next = Item
  end
  List.list_Last = Item
  List.list_count.i32 = List.list_count + 1
end

func listAddName(i32 List, i32 Object, i32 Name)
  i32 Item = Alloc(item_size)
  Item.item_dec0de = 5 - DEC0DE
  Item.item_Object = Object
  Item.item_Name = Name
  if not List.list_First.i32 then
    List.list_First = Item
  else
    List.list_Last.item_Next = Item
  end
  List.list_Last = Item
  List.list_count.i32 = List.list_count + 1
end

// Find a string in a list and return the object
func i32 ListSearch(i32 List, i32 FindName)
  i32 Item = List.list_First
  loop
    breakif not Item
    if strEq(Item.item_Name, FindName) then
      return Item.item_Object
    end
    Item = Item.item_Next
  end
  return 0
end

// Find a string in a list and return the index
func i32 indexListSearch(i32 List, i32 FindName)
  i32 Item = List.list_First
  i32 index = 0
  loop
    breakif not Item
    if strEq(Item.item_Name, FindName) then
      return index
    end
    Item = Item.item_Next
    index = index + 1
  end
  return -1
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Memory management

// Globals
ptr Heap = 0  // Next free memory location

func ptr Alloc(i32 length)
  ptr R = Heap
  Heap = Heap + length
  if Heap mod SIZEINT then
    Heap = Heap + SIZEINT - Heap mod SIZEINT  // Fix the alignment
  end
  return R
end

// Pierre Rossouw 2017  https://github.com/PierreRossouw/dwasm
