// Compile.dwasm v0.1.20170729
// A simple and readable WebAssembly language with self-hosted compiler

// Style conventions:
// Pointers and functions returning pointers start with a Capital letter
// Constants are ALL CAPS

// Memory size in 64kB pages
mem 200 export

data 8 "\ff"  // string length
data 12 ""  // Source code to compile

// Constants
i32 SIZEINT := 4  // Most browsers currently only support 32bit sized WASM memories
i32 DEC0DE := 557785600  // Magic number -0x00dec0de - used for debugging

// Enums
i32 nodes_program    := 0x01  // root node
i32 nodes_fun        := 0x02
i32 nodes_block      := 0x03
i32 nodes_return     := 0x04
i32 nodes_variable   := 0x05
i32 nodes_parameter  := 0x06
i32 nodes_identifier := 0x07
i32 nodes_literal    := 0x08
i32 nodes_binary     := 0x09
i32 nodes_unary      := 0x0a
i32 nodes_call       := 0x0b
i32 nodes_if         := 0x0c
i32 nodes_loop       := 0x0d
i32 nodes_break      := 0x0e
i32 nodes_continue   := 0x0f
i32 nodes_hexwasm    := 0x10  // WebAssembly code byte e.g. tokens_nop
i32 nodes_breakif    := 0x11
i32 nodes_mem        := 0x12
i32 nodes_data       := 0x13
i32 nodes_dotLoad    := 0x14
i32 nodes_dotStore   := 0x15

i32 tokens_identifier  := 43
i32 tokens_strLiteral  := 45
i32 tokens_charLiteral := 46
i32 tokens_numLiteral  := 47
i32 tokens_true        := 48
i32 tokens_false       := 49
i32 tokens_lParen      := 50
i32 tokens_comma       := 51
i32 tokens_rParen      := 52
i32 tokens_dot         := 53
i32 tokens_fun         := 60
i32 tokens_return      := 61
i32 tokens_endfun      := 62
i32 tokens_hexwasm     := 63
i32 tokens_stop        := 64
i32 tokens_nop         := 65
i32 tokens_mem         := 66
i32 tokens_export      := 67
i32 tokens_data        := 68
i32 tokens_loop        := 70
i32 tokens_continue    := 71
i32 tokens_break       := 72
i32 tokens_breakif     := 73
i32 tokens_endloop     := 74
i32 tokens_if          := 80
i32 tokens_then        := 81
i32 tokens_elseif      := 82
i32 tokens_else        := 83
i32 tokens_endif       := 84
i32 tokens_minPrec     := 89
i32 tokens_assign      := 90   // :=
i32 tokens_min         := 91
i32 tokens_max         := 92
i32 tokens_copys       := 93
i32 tokens_or          := 94
i32 tokens_xor         := 95
i32 tokens_and         := 96
i32 tokens_eq          := 97   // =
i32 tokens_ne          := 98   // <>
i32 tokens_lt          := 99   // <
i32 tokens_ltu         := 100  // <+
i32 tokens_le          := 101  // <=
i32 tokens_leu         := 102  // <=+
i32 tokens_gt          := 103  // >
i32 tokens_gtu         := 104  // >+
i32 tokens_ge          := 105  // >=
i32 tokens_geu         := 106  // >=+
i32 tokens_shl         := 107  // <<
i32 tokens_shr         := 108  // >>
i32 tokens_shru        := 109  // >>+
i32 tokens_rotl        := 110  // <-<
i32 tokens_rotr        := 111  // >->
i32 tokens_clz         := 113 
i32 tokens_ctz         := 114 
i32 tokens_cnt         := 115 
i32 tokens_add         := 116  // +
i32 tokens_sub         := 117  // -
i32 tokens_mul         := 118  // *
i32 tokens_div         := 119  // /
i32 tokens_divu        := 120
i32 tokens_mod         := 121
i32 tokens_modu        := 122
i32 tokens_not         := 123
i32 tokens_abs         := 130 
i32 tokens_neg         := 131
i32 tokens_ceil        := 132
i32 tokens_floor       := 133
i32 tokens_trunc       := 134
i32 tokens_round       := 135
i32 tokens_sqrt        := 136
i32 tokens_f64         := 124  // 0x7c  (Data types)
i32 tokens_f32         := 125  // 0x7d 
i32 tokens_i64         := 126  // 0x7e
i32 tokens_i32         := 127  // 0x7f
i32 tokens_bool        := 128  // synonym for i32
i32 tokens_ptr         := 129  // synonym for i32

// Structs
i32 string_max    := 0
i32 string_length := 4
i32 string_Chars  := 8

i32 list_dec0de := 0  // debugging marker
i32 list_First  := 4
i32 list_Last   := 8
i32 list_count  := 12
i32 list_size   := 16

i32 item_dec0de := 0  // debugging marker
i32 item_Next   := 4
i32 item_Object := 8 
i32 item_Name   := 12
i32 item_size   := 16

i32 token_dec0de := 0  // debugging marker
i32 token_kind   := 4
i32 token_Value  := 8
i32 token_line   := 12
i32 token_column := 16
i32 token_size   := 20

i32 node_dec0de     := 0   // debugging marker
i32 node_kind       := 4   // From the nodes_ enum
i32 node_index      := 8   // Zero based index number for funs, variables, parameters
i32 node_String     := 12  // Literal value, or fun/var/parameter name
i32 node_Scope      := 16  // Scope for program/block/loop/fun used for name resolution
i32 node_ANode      := 20  // Binary left, call fun, return expression, then block, or fun body
i32 node_BNode      := 24  // Binary/unary right, else block, fun return, variable assignment
i32 node_CNode      := 28  // If statement condition node
i32 node_Nodes      := 32  // List of child nodes for program/block, or fun locals
i32 node_ParamNodes := 36  // List of params for call/fun
i32 node_type       := 40  // From the tokens_ enum
i32 node_dataType   := 44  // inferred data type
i32 node_Token      := 48
i32 node_size       := 52

i32 scope_dec0de     := 0   // debugging marker
i32 scope_Node       := 4
i32 scope_index      := 8
i32 scope_Parent     := 12
i32 scope_Symbols    := 16
i32 scope_localIndex := 20
i32 scope_size       := 24

// Global variables
ptr Code             := 4
i32 Heap             := 8  // Memory management - reserve 0-7 for null pointers
ptr TokenList        := 0
ptr ExportList       := 0
ptr DataList         := 0
i32 funIndex         := 0  // Next function index number
ptr CurrentTokenItem := 0
ptr CurrentToken     := 0
ptr NextToken        := 0
ptr CurrentScope     := 0
ptr GlobalScope      := 0
ptr RootNode         := 0
ptr CompilerOutput   := 0
ptr BinaryPointer    := 0
i32 emitGlobalCount  := 0
i32 emitFunCount     := 0
ptr CurrentFunNode   := 0
ptr MemExport        := 0
i32 memMin           := 0
i32 memMax           := 0
ptr ErrorList        := 0

fun ptr Compile() export "main"
  i32 length := Code.string_length
  i32 i := Alloc(string_Chars + length)  
  ErrorList := Alloc(list_size)
  lexx()
  if ErrorList.list_count = 0 then parse() endif
  if ErrorList.list_count = 0 then emit(length) endif
  if ErrorList.list_count > 0 then
    parseErrorList()
  endif
  return CompilerOutput + string_length
endfun

fun parseErrorList()
  ptr ErrorItem := ErrorList.list_First
  if ErrorItem then
    ptr ErrorString := NewEmptyString(1000)
    ptr Token := ErrorItem.item_Object
    appendChar(ErrorString, 'E')
    appendChar(ErrorString, 'r')
    appendChar(ErrorString, 'r')
    appendChar(ErrorString, 'o')
    appendChar(ErrorString, 'r')
    appendChar(ErrorString, 13)
    appendString(ErrorString, Token.token_Value)
    appendChar(ErrorString, 13)
    appendChar(ErrorString, 'L')
    appendChar(ErrorString, 'i')
    appendChar(ErrorString, 'n')
    appendChar(ErrorString, 'e')
    appendChar(ErrorString, ' ')
    appendI32(ErrorString, Token.token_line)
    appendChar(ErrorString, ' ')
    appendChar(ErrorString, 'c')
    appendChar(ErrorString, 'o')
    appendChar(ErrorString, 'l')
    appendChar(ErrorString, ' ')
    appendI32(ErrorString, Token.token_column - Token.token_Value.string_length)
    appendChar(ErrorString, 13)
    CompilerOutput := ErrorString
  endif
endfun

// Memory management
fun ptr Alloc(i32 length)
  ptr R := Heap
  Heap := Heap + length
  if Heap mod SIZEINT then
    Heap := Heap + SIZEINT - Heap mod SIZEINT  // Fix the alignment
  endif
  return R
endfun

fun debug(i32 x)
  store32(Alloc(SIZEINT), 1 - DEC0DE)
  store32(Alloc(SIZEINT), x)
endfun

// Pascal-style strings: We store the length instead of using a null terminator
fun i32 NewString(i32 length)
  i32 String := Alloc(string_Chars + length)
  String.string_length := length
  return String
endfun

fun i32 NewEmptyString(i32 max)
  i32 String := Alloc(string_Chars + max)
  String.string_length := 0
  String.string_max := max
  return String
endfun

fun appendString(ptr String, ptr AppendString)
  i32 stringLength := String.string_length
  i32 appendLength := AppendString.string_length
  i32 max := String.string_max
  i32 offset := 0
  if appendLength > 0 and stringLength < max then
    loop
      setChar(String, stringLength, getChar(AppendString, offset))
      stringLength := stringLength + 1
      breakif stringLength >= max
      offset := offset + 1
      breakif offset >= appendLength
    endloop
    String.string_length := stringLength
  endif
endfun

fun appendI32(ptr String, i32 i)
  i32 stringLength := String.string_length
  i32 appendLength := decimalStringLength(i)
  i32 max := String.string_max
  i32 offset := appendLength
  if stringLength + appendLength <= max then
    loop
      i32 chr := '0' + i mod 10
      offset := offset - 1
      setChar(String, stringLength + offset, chr)
      i := i / 10
      breakif not i
      breakif not offset 
    endloop  
    String.string_length := stringLength + appendLength
  endif
endfun

fun appendChar(ptr String, i32 chr)
  i32 stringLength := String.string_length
  i32 max := String.string_max
  if stringLength < max then
    setChar(String, stringLength, chr)
    String.string_length := stringLength + 1
  endif
endfun

fun i32 decimalStringLength(i32 i)
  i32 length := 1
  loop
    i := i / 10
    breakif not i
    length := length + 1
  endloop
  return length
endfun

fun i32 getChar(i32 String, i32 offset)
  return load8u(String + string_Chars + offset)
endfun

fun setChar(i32 String, i32 offset, i32 chr)
  store8(String + string_Chars + offset, chr)
endfun

fun i32 Substring(i32 String, i32 offset, i32 length)
  if offset >= String.string_length then
    length := 0
  endif
  if offset + length >= String.string_length then
    length := String.string_length - offset
  endif
  i32 R := NewString(length)
  loop
    breakif length = 0
    length := length - 1
    setChar(R, length, getChar(String, offset + length))
  endloop
  return R
endfun

fun bool strCompare(i32 A, i32 B)
  i32 length := A.string_length
  if length = B.string_length then
    i32 offset := 0
    loop
      if getChar(A, offset) <> getChar(B, offset) then
        return false
      endif
      breakif offset >= length
      offset := offset + 1
    endloop
  else
    return false
  endif
  return true
endfun

fun bool strCompare32(i32 V, i32 a)
  i32 length := V.string_length
  if length = 0 or length > 4 then
    return false
  else
    if V.string_Chars <> a then return false endif
  endif
  return true
endfun

fun bool strCompare64(i32 V, i64 a)
  i32 length := V.string_length
  if length < 5 or length > 8 then
    return false
  else
    if load64(V + string_Chars) <> a then return false endif
  endif
  return true
endfun

fun i32 hexCharToInt(i32 char)
  if char >= '0' and char <= '9' then
    return char - '0'
  elseif char >= 'a' and char <= 'f' then
    return char - 'a' + 10
  elseif char >= 'A' and char <= 'F' then
    return char - 'A' + 10
  endif
  return 0
endfun

// Strings may contain escaped hex bytes for example "\5a" -> "Z"
fun decodeString(i32 S)
  i32 length := S.string_length
  i32 i := 0
  i32 o := 0
  loop
    breakif i >= length
    if getChar(S, i) = 92 then // backslash
      i := i + 1
      if isNumber(getChar(S, i), true) and isNumber(getChar(S, i + 1), true) then
        i32 char := hexCharToInt(getChar(S, i)) 
        char := char * 16
        char := char + hexCharToInt(getChar(S, i + 1))
        setChar(S, o, char)
        i := i + 1
      endif
    elseif i > o then
      setChar(S, o, getChar(S, i))
    endif
    i := i + 1
    o := o + 1
  endloop
  S.string_length := o
  loop
    breakif o >= length
    setChar(S, o, 0)
    o := o + 1
  endloop
endfun

// Lists
fun listAdd(i32 List, i32 Object)
  i32 Item := Alloc(item_size)
  Item.item_Object := Object
  if not List.list_First then
    List.list_First := Item
  else
    List.list_Last.item_Next := Item
  endif
  List.list_Last := Item
  List.list_count := List.list_count + 1
endfun

fun listAddName(i32 List, i32 Object, i32 Name)
  i32 Item := Alloc(item_size)
  Item.item_dec0de := 5 - DEC0DE
  Item.item_Object := Object
  Item.item_Name := Name
  if not List.list_First then
    List.list_First := Item
  else
    List.list_Last.item_Next := Item
  endif
  List.list_Last := Item
  List.list_count := List.list_count + 1
endfun

// Find a string in a list
fun i32 ListSearch(i32 List, i32 FindName)
  i32 Item := List.list_First
  loop
    breakif not Item
    if strCompare(Item.item_Name, FindName) then
      return Item.item_Object
    endif
    Item := Item.item_Next
  endloop
  return 0
endfun

// Lexer XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun addToken(i32 kind, i32 Value, i32 line, i32 column)
  i32 Token := Alloc(token_size)
  Token.token_dec0de := 6 - DEC0DE
  Token.token_kind := kind
  Token.token_Value := Value
  Token.token_line := line
  Token.token_column := column
  listAdd(TokenList, Token)
endfun

fun processToken(i32 Val, i32 line, i32 column)
  i32 kind := tokens_identifier
  if     strCompare32(Val, '(')        then kind := tokens_lParen 
  elseif strCompare32(Val, ',')        then kind := tokens_comma 
  elseif strCompare32(Val, ')')        then kind := tokens_rParen 
  elseif strCompare32(Val, 'true')     then kind := tokens_true
  elseif strCompare64(Val, 'false')    then kind := tokens_false
  elseif strCompare32(Val, 'fun')      then kind := tokens_fun
  elseif strCompare64(Val, 'return')   then kind := tokens_return
  elseif strCompare64(Val, 'endfun')   then kind := tokens_endfun
  elseif strCompare32(Val, 'stop')     then kind := tokens_stop
  elseif strCompare32(Val, 'nop')      then kind := tokens_nop
  elseif strCompare32(Val, 'mem')      then kind := tokens_mem
  elseif strCompare32(Val, 'data')     then kind := tokens_data
  elseif strCompare64(Val, 'export')   then kind := tokens_export
  elseif strCompare32(Val, 'loop')     then kind := tokens_loop
  elseif strCompare64(Val, 'continue') then kind := tokens_continue
  elseif strCompare64(Val, 'break')    then kind := tokens_break
  elseif strCompare64(Val, 'breakif')  then kind := tokens_breakif
  elseif strCompare64(Val, 'endloop')  then kind := tokens_endloop
  elseif strCompare32(Val, 'if')       then kind := tokens_if
  elseif strCompare32(Val, 'then')     then kind := tokens_then
  elseif strCompare32(Val, 'else')     then kind := tokens_else
  elseif strCompare64(Val, 'elseif')   then kind := tokens_elseif
  elseif strCompare64(Val, 'endif')    then kind := tokens_endif
  elseif strCompare32(Val, 'i32')      then kind := tokens_i32
  elseif strCompare32(Val, 'i64')      then kind := tokens_i64
  elseif strCompare32(Val, 'f32')      then kind := tokens_f32
  elseif strCompare32(Val, 'f64')      then kind := tokens_f64
  elseif strCompare32(Val, 'bool')     then kind := tokens_bool
  elseif strCompare32(Val, 'ptr')      then kind := tokens_ptr
  elseif strCompare32(Val, ':=')       then kind := tokens_assign
  elseif strCompare32(Val, 'or')       then kind := tokens_or
  elseif strCompare32(Val, 'xor')      then kind := tokens_xor
  elseif strCompare32(Val, 'and')      then kind := tokens_and
  elseif strCompare32(Val, '=')        then kind := tokens_eq
  elseif strCompare32(Val, '<>')       then kind := tokens_ne
  elseif strCompare32(Val, '<')        then kind := tokens_lt
  elseif strCompare32(Val, '<+')       then kind := tokens_ltu
  elseif strCompare32(Val, '<=')       then kind := tokens_le 
  elseif strCompare32(Val, '<=+')      then kind := tokens_leu 
  elseif strCompare32(Val, '>')        then kind := tokens_gt 
  elseif strCompare32(Val, '>+')       then kind := tokens_gtu 
  elseif strCompare32(Val, '>=')       then kind := tokens_ge 
  elseif strCompare32(Val, '>=+')      then kind := tokens_geu   
  elseif strCompare32(Val, '<<')       then kind := tokens_shl 
  elseif strCompare32(Val, '>>')       then kind := tokens_shr 
  elseif strCompare32(Val, '>>+')      then kind := tokens_shru 
  elseif strCompare32(Val, '<-<')      then kind := tokens_rotl 
  elseif strCompare32(Val, '>->')      then kind := tokens_rotr 
  elseif strCompare32(Val, '+')        then kind := tokens_add 
  elseif strCompare32(Val, '-')        then kind := tokens_sub 
  elseif strCompare32(Val, '*')        then kind := tokens_mul 
  elseif strCompare32(Val, '/')        then kind := tokens_div 
  elseif strCompare32(Val, 'mod')      then kind := tokens_mod 
  elseif strCompare32(Val, 'modu')     then kind := tokens_modu 
  elseif strCompare32(Val, 'not')      then kind := tokens_not 
  elseif strCompare32(Val, 'neg')      then kind := tokens_neg 
  elseif strCompare64(Val, 'ceiling')  then kind := tokens_ceil
  elseif strCompare64(Val, 'floor')    then kind := tokens_floor
  elseif strCompare64(Val, 'trunc')    then kind := tokens_trunc
  elseif strCompare64(Val, 'round')    then kind := tokens_round
  elseif strCompare64(Val, 'sqrt')     then kind := tokens_sqrt
  elseif strCompare32(Val, 'abs')      then kind := tokens_abs
  elseif strCompare32(Val, 'clz')      then kind := tokens_clz 
  elseif strCompare32(Val, 'ctz')      then kind := tokens_ctz 
  elseif strCompare32(Val, 'cnt')      then kind := tokens_cnt 
  endif
  addToken(kind, Val, line, column)
endfun

fun bool isAlpha(i32 chr)
  return (chr >= 'a' and chr <= 'z') or (chr >= 'A' and chr <= 'Z') or (chr = '_')
endfun

fun bool isNumber(i32 chr, bool hexNum)
  if chr >= '0' and chr <= '9' then
    return true
  elseif hexNum then
    if (chr >= 'a' and chr <= 'f') or (chr >= 'A' and chr <= 'F') then 
      return true 
    endif
  endif
  return false
endfun

fun bool isHexwasm(i32 chr1, i32 chr2, i32 chr3)
  return chr1 = 'x' and isNumber(chr2, true) and isNumber(chr3, true)
endfun

fun bool isPunctuator(i32 chr)
  return chr = '(' or chr = ')' or chr = ','
endfun

fun bool isOperatorChar(i32 chr)
  return chr = '=' or chr = '+' or chr = '-' or chr = '/' or chr = '^' or
         chr = '<' or chr = '>' or chr = '*' or chr = ':' 
endfun

fun lexx()
  TokenList := Alloc(list_size)
  i32 pos := -1
  i32 line := 1
  i32 column := 0
  i32 length := Code.string_length
  i32 start := 0
  i32 Val := 0
  loop
    pos := pos + 1
    column := column + 1
    i32 chr := getChar(Code, pos) 
    if chr = 10 then  // newline
      line := line + 1
      column := 0
    elseif isHexwasm(chr, getChar(Code, pos + 1), getChar(Code, pos + 2)) then
      Val := Substring(Code, pos - 1, 4)
      setChar(Val, 0, '0')
      addToken(tokens_hexwasm, Val, line, column)
      pos := pos + 2
      column := column + 2
    elseif isAlpha(chr) then
      start := pos
      loop
        if (not isAlpha(chr)) and (not isNumber(chr, false)) then
          pos := pos - 1
          column := column - 1
          break
        endif
        pos := pos + 1
        column := column + 1
        chr := getChar(Code, pos)
      endloop
      Val := Substring(Code, start, pos - start + 1)
      processToken(Val, line, column)
      if getChar(Code, pos + 1) = '.' and isAlpha(getChar(Code, pos + 2)) then
        pos := pos + 1
        column := column + 1
        chr := getChar(Code, pos)
        addToken(tokens_dot, Val, line, column)
      endif
    elseif chr = 39 then  // single quote
      pos := pos + 1
      column := column + 1
      chr := getChar(Code, pos)
      start := pos
      loop
        breakif chr = 39
        pos := pos + 1
        column := column + 1
        chr := getChar(Code, pos)
      endloop
      Val := Substring(Code, start, pos - start)
      addToken(tokens_charLiteral, Val, line, column)
    elseif chr = '"' then
      pos := pos + 1
      column := column + 1
      chr := getChar(Code, pos)
      start := pos
      loop
        breakif chr = '"'
        pos := pos + 1
        column := column + 1
        chr := getChar(Code, pos)
      endloop
      Val := Substring(Code, start, pos - start)
      decodeString(Val)
      addToken(tokens_strLiteral, Val, line, column)
    elseif isNumber(chr, false) or ((chr = '-') and isNumber(getChar(Code, pos + 1), false)) then
      start := pos
      bool isHex := false
      loop
        if (not isNumber(chr, isHex)) and (chr <> '-') then
          if start + 1 = pos and chr = 'x' then
            isHex := true
          else
            pos := pos - 1
            column := column - 1
            break
          endif
        endif
        pos := pos + 1
        column := column + 1
        chr := getChar(Code, pos)
      endloop
      if chr = '.' and not isHex then
        pos := pos + 2
        column := column + 2
        chr := getChar(Code, pos)
        loop
          if (not isNumber(chr, isHex)) then
            pos := pos - 1
            column := column - 1
            break
          endif
          pos := pos + 1
          column := column + 1
          chr := getChar(Code, pos)
        endloop
      endif
      Val := Substring(Code, start, pos - start + 1)
      addToken(tokens_numLiteral, Val, line, column)
    elseif chr = '/' and getChar(Code, pos + 1) = '/' then
      loop
        if chr = 10 or chr = 13 then  // LF or CR
          column := 0
          line := line + 1
          break
        endif
        pos := pos + 1
        column := column + 1
        chr := getChar(Code, pos)
      endloop
    elseif isPunctuator(chr) then
      Val := Substring(Code, pos, 1)
      processToken(Val, line, column)
    elseif isOperatorChar(chr) then
      if isOperatorChar(getChar(Code, pos + 1)) then
        if isOperatorChar(getChar(Code, pos + 2)) then
          Val := Substring(Code, pos, 3)
          pos := pos + 2
          column := column + 2
        else
          Val := Substring(Code, pos, 2)
          pos := pos + 1
          column := column + 1
        endif
      else
        Val := Substring(Code, pos, 1)
      endif
      processToken(Val, line, column)
    endif
    breakif pos >= length
  endloop
endfun

// Scoper XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun pushScope(i32 Node)
  i32 Scope := Alloc(scope_size)
  Scope.scope_dec0de := 3 - DEC0DE
  Scope.scope_Symbols := Alloc(list_size)
  Scope.scope_Node := Node
  if CurrentScope then
    Scope.scope_index := CurrentScope.scope_index + 1
    Scope.scope_Parent := CurrentScope
  endif
  Node.node_Scope := Scope
  CurrentScope := Scope
endfun

fun popScope()
  CurrentScope := CurrentScope.scope_Parent
endfun

fun i32 LookupFunctionScope(i32 Scope)
  i32 FunScope := Scope
  loop
    breakif not FunScope  // error
    breakif FunScope.scope_Node.node_kind = nodes_fun
    breakif FunScope.scope_Node.node_kind = nodes_program
    FunScope := FunScope.scope_Parent
  endloop
  return FunScope
endfun

fun scopeRegister(i32 Scope, i32 Name, i32 Node)
  i32 nodeKind := Node.node_kind
  listAddName(Scope.scope_Symbols, Node, Name)
  if nodeKind = nodes_variable or nodeKind = nodes_parameter then
    i32 FunScope := LookupFunctionScope(Scope)
    i32 nextIndex := FunScope.scope_localIndex
    Node.node_Scope := FunScope
    Node.node_index := nextIndex
    FunScope.scope_localIndex := nextIndex + 1
  endif
endfun

fun i32 ScopeResolve(i32 Scope, i32 Name)
  i32 Node := 0
  i32 RecurseScope := Scope
  loop
    breakif not RecurseScope
    Node := ListSearch(RecurseScope.scope_Symbols, Name)
    breakif Node
    RecurseScope := RecurseScope.scope_Parent
  endloop
  return Node
endfun

// Parser XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun ptr NewNode()
  ptr Node := Alloc(node_size)
  Node.node_Scope := CurrentScope
  Node.node_dec0de := 2 - DEC0DE
  Node.node_Token := CurrentToken
  return Node
endfun

fun nextToken()
  CurrentTokenItem := CurrentTokenItem.item_Next
  if CurrentTokenItem then
    CurrentToken := CurrentTokenItem.item_Object
  else
    CurrentToken := 0
  endif
  ptr NextTokenItem := CurrentTokenItem.item_Next
  if NextTokenItem then
    NextToken := NextTokenItem.item_Object
  else
    NextToken := 0
  endif
endfun

fun bool isBinaryOperator(ptr Token)
  i32 kind := Token.token_kind
  return kind = tokens_assign or kind = tokens_add or kind = tokens_sub or kind = tokens_mul or
         kind = tokens_div or kind = tokens_mod or kind = tokens_or or kind = tokens_and or
         kind = tokens_lt or kind = tokens_eq or kind = tokens_ne or kind = tokens_lt or
         kind = tokens_le or kind = tokens_gt or kind = tokens_ge or kind = tokens_shl or
         kind = tokens_shr or kind = tokens_xor or kind = tokens_ltu or kind = tokens_leu or 
         kind = tokens_gtu or kind = tokens_geu or kind = tokens_shru or kind = tokens_rotl or
         kind = tokens_rotr or kind = tokens_modu
endfun

fun bool isUnaryOperator(ptr Token)
  i32 kind := Token.token_kind
  return kind = tokens_sub or kind = tokens_not or kind = tokens_cnt or kind = tokens_clz or 
         kind = tokens_ctz or kind = tokens_abs or kind = tokens_neg or kind = tokens_ceil or
         kind = tokens_floor or kind = tokens_trunc or kind = tokens_round or kind = tokens_sqrt 
endfun

fun bool isLiteral(ptr Token)
  i32 kind := Token.token_kind
  return kind = tokens_numLiteral or kind = tokens_charLiteral or 
         kind = tokens_true or kind = tokens_false
endfun

fun bool isNativeType(ptr Token)
  i32 kind := Token.token_kind
  return kind = tokens_i32 or kind = tokens_i64 or kind = tokens_f32 or kind = tokens_f64 or 
         kind = tokens_bool or kind = tokens_ptr
endfun

fun eatToken(i32 kind)
  if CurrentToken.token_kind = kind then
    nextToken()
  else
    listAdd(ErrorList, CurrentToken)
    debug(kind)
    debug(CurrentToken.token_kind)
    debug(CurrentToken)
  endif
endfun

fun ptr ParseFunParams()
  ptr Params := Alloc(list_size)
  eatToken(tokens_lParen)
  loop
    i32 type := CurrentToken.token_kind
    breakif type = tokens_rParen
    nextToken()
    ptr FunParamNode := NewNode()
    FunParamNode.node_kind := nodes_parameter
    FunParamNode.node_type := type
    FunParamNode.node_dataType := type
    ptr Name := CurrentToken.token_Value
    FunParamNode.node_String := Name
    listAddName(Params, FunParamNode, Name)
    nextToken()
    breakif CurrentToken.token_kind <> tokens_comma
    nextToken()
  endloop
  eatToken(tokens_rParen)
  return Params
endfun

fun ptr ParseFunBlock()
  ptr Node := NewNode()
  ptr BodyList := Alloc(list_size)
  Node.node_kind := nodes_block
  Node.node_Nodes := BodyList
  Node.node_Scope := CurrentScope
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind = tokens_endfun
    ptr ChildNode := ParseStatement()
    breakif not ChildNode
    listAdd(BodyList, ChildNode)
  endloop
  return Node
endfun

fun i32 ParseFunDeclaration(i32 type, ptr Name)
  ptr Node := NewNode()
  ptr Locals := Alloc(list_size)
  Node.node_kind := nodes_fun
  Node.node_index := funIndex
  funIndex := funIndex + 1
  Node.node_type := type
  Node.node_dataType := type
  Node.node_String := Name
  Node.node_Nodes := Locals
  scopeRegister(CurrentScope, Name, Node)
  ptr ParamList := ParseFunParams()
  Node.node_ParamNodes := ParamList
  pushScope(Node)
  ptr ParamItem := ParamList.list_First
  loop
    breakif not ParamItem
    ptr ParamName := ParamItem.item_Name
    scopeRegister(CurrentScope, ParamName, ParamItem.item_Object)
    ParamItem := ParamItem.item_Next
  endloop
  if CurrentToken.token_kind = tokens_export then
    eatToken(tokens_export)
    if CurrentToken.token_kind = tokens_strLiteral then
      listAddName(ExportList, Node, CurrentToken.token_Value)
      eatToken(tokens_strLiteral)
    else
      listAddName(ExportList, Node, Name)
    endif
  endif
  Node.node_ANode := ParseFunBlock()
  popScope()
  eatToken(tokens_endfun)
  return Node
endfun

fun ptr ParseFun()
  i32 funType := 0
  eatToken(tokens_fun)
  if isNativeType(CurrentToken) then
    funType := CurrentToken.token_kind
    nextToken()
  endif
  ptr Name := CurrentToken.token_Value
  nextToken()
  return ParseFunDeclaration(funType, Name)
endfun

fun ptr ParseBreak()
  ptr Node := NewNode()
  Node.node_kind := nodes_break
  eatToken(tokens_break)
  return Node
endfun

fun ptr ParseContinue()
  ptr Node := NewNode()
  Node.node_kind := nodes_continue
  eatToken(tokens_continue)
  return Node
endfun

fun ptr ParseLiteral()
  ptr Node := NewNode()
  Node.node_kind := nodes_literal
  Node.node_String := CurrentToken.token_Value
  Node.node_type := CurrentToken.token_kind
  nextToken()
  return Node
endfun

fun ptr ParseIdentifier()
  ptr Node := NewNode()
  Node.node_kind := nodes_identifier
  Node.node_String := CurrentToken.token_Value
  Node.node_type := CurrentToken.token_kind
  nextToken()
  return Node
endfun

fun ptr ParseCallParams()
  ptr ParamList := Alloc(list_size)
  eatToken(tokens_lParen)
  loop
    breakif CurrentToken.token_kind = tokens_rParen
    listAdd(ParamList, ParseExpression(tokens_minPrec))
    breakif CurrentToken.token_kind <> tokens_comma
    eatToken(tokens_comma)
  endloop
  eatToken(tokens_rParen)
  return ParamList
endfun

fun ptr ParseCallExpression(ptr Callee)
  ptr Node := NewNode()
  Node.node_kind := nodes_call
  Node.node_ANode := Callee
  Node.node_ParamNodes := ParseCallParams()
  return Node
endfun

fun ptr parseUnaryExpression()
  ptr Node := NewNode()
  Node.node_kind := nodes_unary
  Node.node_type := CurrentToken.token_kind
  Node.node_String := CurrentToken.token_Value
  nextToken()
  Node.node_BNode := ParseExpression(tokens_add)
  return Node
endfun

fun ptr ParseDotLoad()
  ptr Node := NewNode()
  ptr BodyList := Alloc(list_size)
  Node.node_kind := nodes_dotLoad
  Node.node_Nodes := BodyList
  listAdd(BodyList, ParseIdentifier())
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind <> tokens_dot
    eatToken(tokens_dot)
    if isNativeType(CurrentToken) then
      Node.node_dataType := CurrentToken.token_kind 
      nextToken()
      break
    else
      listAdd(BodyList, ParseIdentifier())
    endif
  endloop
  return Node
endfun

// A.B.C.i32 := x
fun ptr ParseDotStore()
  ptr Node := NewNode()
  ptr BodyList := Alloc(list_size)
  i32 dataType := 0
  Node.node_kind := nodes_dotStore
  Node.node_Nodes := BodyList
  listAdd(BodyList, ParseIdentifier())
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind <> tokens_dot
    eatToken(tokens_dot)
    if isNativeType(CurrentToken) then
      dataType := CurrentToken.token_kind
      Node.node_dataType := dataType 
      nextToken()
      break
    else
      listAdd(BodyList, ParseIdentifier())
    endif
  endloop
  eatToken(tokens_assign)
  Node.node_ANode := ParseExpression(tokens_minPrec)
  Node.node_ANode.node_dataType := dataType
  return Node
endfun

fun ptr ParsePrefix()
  ptr Node := 0
  if isLiteral(CurrentToken) then
    Node := ParseLiteral()
  elseif CurrentToken.token_kind = tokens_identifier then
    i32 nextKind := 0
    if NextToken then nextKind := NextToken.token_kind endif
    if nextKind = tokens_dot then
      Node := ParseDotLoad()
    else
      Node := ParseIdentifier()
    endif
  elseif CurrentToken.token_kind = tokens_lParen then
    nextToken()
    Node := ParseExpression(tokens_minPrec)
    eatToken(tokens_rParen)
  elseif isUnaryOperator(CurrentToken) then
    Node := parseUnaryExpression()
  endif
  return Node
endfun

fun ptr ParseBinaryExpression(i32 level, ptr Left)
  ptr Node := 0
  i32 precedence := CurrentToken.token_kind  // node_kind doubles as the precedence
  if level > precedence then
    Node := Left
  else
    Node := NewNode()
    Node.node_kind := nodes_binary
    Node.node_type := CurrentToken.token_kind
    Node.node_String := CurrentToken.token_Value
    Node.node_ANode := Left
    nextToken()
    Node.node_BNode := ParseExpression(precedence)
  endif
  return Node
endfun

fun ptr ParseInfix(i32 level, ptr Left)
  ptr Node := 0
  if isBinaryOperator(CurrentToken) then
    Node := ParseBinaryExpression(level, Left)
  elseif CurrentToken.token_kind = tokens_lParen then
    Node := ParseCallExpression(Left)
  else
    Node := Left
  endif
  return Node
endfun

fun ptr ParseBreakif()
  ptr Node := NewNode()
  Node.node_kind := nodes_breakif
  eatToken(tokens_breakif)
  Node.node_CNode := ParseExpression(tokens_minPrec)
  return Node
endfun

fun ptr ParseExpression(i32 level)
  ptr Node := ParsePrefix()
  loop
    breakif not CurrentToken
    ptr Expr := ParseInfix(level, Node)
    breakif Expr = 0 or Expr = Node
    Node := Expr
  endloop
  return Node
endfun

fun ptr ParseHexwasmStatement()
  ptr Node := NewNode()
  Node.node_kind := nodes_hexwasm
  Node.node_type := strToI32(CurrentToken.token_Value)
  eatToken(tokens_hexwasm)
  return Node
endfun

fun ptr ParseStopStatement()
  ptr Node := NewNode()
  Node.node_kind := nodes_hexwasm
  Node.node_type := 0x00
  eatToken(tokens_stop)
  return Node
endfun

fun ptr ParseNopStatement()
  ptr Node := NewNode()
  Node.node_kind := nodes_hexwasm
  Node.node_type := 0x01
  eatToken(tokens_nop)
  return Node
endfun

fun ptr ParseReturnStatement()
  ptr Node := NewNode()
  eatToken(tokens_return)
  Node.node_kind := nodes_return
  Node.node_ANode := ParseExpression(tokens_minPrec)
  return Node
endfun

fun ptr ParseIfBlock()
  ptr Node := NewNode()
  ptr BodyList := Alloc(list_size)
  Node.node_kind := nodes_block
  Node.node_Nodes := BodyList
  Node.node_Scope := CurrentScope
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind = tokens_else
    breakif CurrentToken.token_kind = tokens_elseif
    breakif CurrentToken.token_kind = tokens_endif
    ptr ChildNode := ParseStatement()
    breakif not ChildNode
    listAdd(BodyList, ChildNode)
  endloop
  return Node
endfun

fun ptr ParseIfStatement(bool isElseif)
  ptr Node := NewNode()
  if not isElseif then eatToken(tokens_if) endif
  Node.node_kind := nodes_if
  Node.node_CNode := ParseExpression(tokens_minPrec)
  eatToken(tokens_then)
  pushScope(Node)
  Node.node_ANode := ParseIfBlock()
  popScope()
  if CurrentToken.token_kind = tokens_elseif then
    eatToken(tokens_elseif)
    pushScope(Node)
    Node.node_BNode := ParseIfStatement(true)
    popScope()
  endif
  if CurrentToken.token_kind = tokens_else then
    eatToken(tokens_else)
    pushScope(Node)
    Node.node_BNode := ParseIfBlock()
    popScope()
  endif
  if not isElseif then eatToken(tokens_endif) endif
  return Node
endfun

fun ptr ParseLoopBlock()
  ptr Node := NewNode()
  ptr BodyList := Alloc(list_size)
  Node.node_kind := nodes_block
  Node.node_Nodes := BodyList
  Node.node_Scope := CurrentScope
  loop
    breakif not CurrentToken
    breakif CurrentToken.token_kind = tokens_endloop
    ptr ChildNode := ParseStatement()
    breakif not ChildNode
    listAdd(BodyList, ChildNode)
  endloop
  return Node
endfun

fun ptr ParseLoopStatement()
  ptr Node := NewNode()
  eatToken(tokens_loop)
  Node.node_kind := nodes_loop
  pushScope(Node)
  Node.node_ANode := ParseLoopBlock()
  popScope()
  eatToken(tokens_endloop)
  return Node
endfun

fun ptr ParseDeclaration()
  i32 type := CurrentToken.token_kind
  nextToken()
  ptr Name := CurrentToken.token_Value
  nextToken()
  ptr Node := NewNode()
  Node.node_kind := nodes_variable
  Node.node_type := type
  Node.node_dataType := type
  Node.node_String := Name
  scopeRegister(CurrentScope, Name, Node)
  eatToken(tokens_assign)
  Node.node_BNode := ParseExpression(tokens_minPrec)
  if CurrentScope.scope_Parent then
    ptr FunScope := LookupFunctionScope(CurrentScope)
    ptr FunNode := FunScope.scope_Node
    ptr FunLocalsList := FunNode.node_Nodes
    if not FunLocalsList then
      FunLocalsList := Alloc(list_size)
      FunNode.node_Nodes := FunLocalsList
    endif
    listAdd(FunLocalsList, Node)
  endif
  return Node
endfun

fun ptr ParseMem()
  ptr Node := NewNode()
  ptr MemToken := CurrentToken
  Node.node_kind := nodes_mem
  eatToken(tokens_mem)
  memMin := strToI32(CurrentToken.token_Value)
  nextToken()
  if CurrentToken.token_kind = tokens_numLiteral then
    memMax := strToI32(CurrentToken.token_Value)
    nextToken()
  endif
  if CurrentToken.token_kind = tokens_export then
    eatToken(tokens_export)
    if CurrentToken.token_kind = tokens_strLiteral then
      MemExport := CurrentToken.token_Value
      nextToken()
    else
      MemExport := MemToken.token_Value
    endif
  endif
  return Node
endfun

fun ptr ParseData()
  ptr Node := NewNode()
  Node.node_kind := nodes_data
  eatToken(tokens_data)
  if CurrentToken.token_kind = tokens_numLiteral then
    ptr OffsetToken := CurrentToken
    Node.node_ANode := OffsetToken
    nextToken()
    if CurrentToken.token_kind = tokens_strLiteral then
      ptr DataToken := CurrentToken
      listAddName(DataList, OffsetToken, DataToken)
      Node.node_BNode := DataToken
      nextToken()
    endif
  endif
  return Node
endfun

fun ptr ParseStatement()
  ptr Node := 0
  i32 kind := CurrentToken.token_kind
  if isNativeType(CurrentToken) then Node := ParseDeclaration()
  elseif kind = tokens_mem      then Node := ParseMem()
  elseif kind = tokens_data     then Node := ParseData()
  elseif kind = tokens_fun      then Node := ParseFun()
  elseif kind = tokens_return   then Node := ParseReturnStatement()
  elseif kind = tokens_hexwasm  then Node := ParseHexwasmStatement()
  elseif kind = tokens_stop     then Node := ParseStopStatement()
  elseif kind = tokens_nop      then Node := ParseNopStatement()
  elseif kind = tokens_if       then Node := ParseIfStatement(false)
  elseif kind = tokens_loop     then Node := ParseLoopStatement()
  elseif kind = tokens_breakif  then Node := ParseBreakif()
  elseif kind = tokens_continue then Node := ParseContinue()
  elseif kind = tokens_break    then Node := ParseBreak()
  elseif kind = tokens_identifier and NextToken.token_kind = tokens_dot then
    Node := ParseDotStore()
  else
    Node := ParseExpression(tokens_minPrec)
  endif
  return Node
endfun

fun parse()
  RootNode := NewNode()
  ExportList := Alloc(list_size)
  DataList := Alloc(list_size)
  CurrentTokenItem := TokenList.list_First
  CurrentToken := CurrentTokenItem.item_Object
  RootNode.node_kind := nodes_program
  pushScope(RootNode)
  GlobalScope := CurrentScope  
  ptr BodyList := Alloc(list_size)
  RootNode.node_Nodes := BodyList
  loop
    breakif not CurrentToken
    ptr Child := ParseStatement()
    breakif not Child
    listAdd(BodyList, Child)
  endloop
endfun

// Compiler XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun i32 strToI32(ptr V)  // Supports ints and 0x-prefixed hex
  bool isHex := false
  i32 i := 0
  i32 length := V.string_length
  i32 offset := 0
  i32 chr := 0
  if length >= 3 then
    if getChar(V, 0) = '0' and getChar(V, 1) = 'x' then
      isHex := true
    elseif getChar(V, 0) = '-' and getChar(V, 1) = '0' and getChar(V, 2) = 'x' then
      isHex := true
    endif
  endif
  if isHex then
    offset := 2
    if getChar(V, 2) = 'x' then offset := 3 endif
    loop
      breakif offset >= length
      i := i * 16
      chr := getChar(V, offset)
      if chr >= '0' and chr <= '9' then
        i := i + chr - '0'
      elseif chr >= 'a' and chr <= 'f' then
        i := i + chr - 'a' + 10
      elseif chr >= 'A' and chr <= 'F' then
        i := i + chr - 'A' + 10
      endif
      offset := offset + 1
    endloop
  else
    loop
      breakif offset >= length
      i := i * 10
      chr := getChar(V, offset)
      if chr >= '0' and chr <= '9' then
        i := i + chr - '0'
      endif
      offset := offset + 1
    endloop
  endif
  if getChar(V, 0) = '-' then i := -i endif
  return i
endfun

fun i64 strToI64(ptr V)
  bool isHex := false
  i64 i := 0
  i32 length := V.string_length
  i32 offset := 0
  i32 chr := 0
  if length >= 3 then
    if getChar(V, 0) = '0' and getChar(V, 1) = 'x' then
      isHex := true
    endif
  endif
  if isHex then
    offset := 2
    loop
      breakif offset >= length
      i := i * 16
      chr := getChar(V, offset)
      if chr >= '0' and chr <= '9' then
        i := i + i32_i64(chr) - '0'
      elseif chr >= 'a' and chr <= 'f' then
        i := i + i32_i64(chr) - 'a' + 10
      elseif chr >= 'A' and chr <= 'F' then
        i := i + i32_i64(chr) - 'A' + 10
      endif
      offset := offset + 1
    endloop
  else
    loop
      breakif offset >= length
      i := i * 10
      chr := getChar(V, offset)
      if chr >= '0' and chr <= '9' then
        i := i + i32_i64(chr) - '0'
      endif
      offset := offset + 1
    endloop
  endif
  if getChar(V, 0) = '-' then i := -i endif
  return i
endfun

fun f32 strToF32(ptr V)
  f32 f := 0
  i32 length := V.string_length
  i32 offset := 0
  f32 d := 1
  bool isAfterDot := false
  loop
    breakif offset >= length
    i32 chr := getChar(V, offset)
    if chr = '.' then
      isAfterDot := true
    else
      if isAfterDot then 
        f := f + i32_f32(chr - '0') / d
        d := d * 10
      else
        if chr >= '0' and chr <= '9' then
          f := f * 10 + i32_f32(chr - '0')
        endif
      endif
    endif
    offset := offset + 1
  endloop
  if getChar(V, 0) = '-' then f := -f endif
  return f
endfun

fun f64 strToF64(ptr V)
  f64 f := f
  i32 length := V.string_length
  i32 offset := 0
  f64 d := 1
  bool isAfterDot := false
  loop
    breakif offset >= length
    i32 chr := getChar(V, offset)
    if chr = '.' then
      isAfterDot := true
    else
      if isAfterDot then 
        f := f + i32_f64(chr - '0') / d
        d := d * 10
      else
        if chr >= '0' and chr <= '9' then
          f := f * 10 + i32_f64(chr - '0')
        endif
      endif
    endif
    offset := offset + 1
  endloop
  if getChar(V, 0) = '-' then f := -f endif
  return f
endfun

fun emitByte(i32 byte)
  store8(BinaryPointer, byte)
  BinaryPointer := BinaryPointer + 1
endfun

fun emitI32(i32 i)
  store32(BinaryPointer, i)
  BinaryPointer := BinaryPointer + 4
endfun

fun emitF32(f32 f)
  storeF32(BinaryPointer, f)
  BinaryPointer := BinaryPointer + 4
endfun

fun emitF64(f64 f)
  storeF64(BinaryPointer, f)
  BinaryPointer := BinaryPointer + 8
endfun

fun emitString(ptr S)
  i32 length := S.string_length
  i32 i := 0
  loop
    breakif i >= length
    emitByte(getChar(S, i))
    i := i + 1
  endloop
endfun

fun i32 uLebLen(i32 i)
  if i <= 127 then return 1
  elseif i <= 16383 then return 2
  elseif i <= 2097151 then return 3
  elseif i <= 268435455 then return 4
  endif
  return 5
endfun

fun emitUleb(i32 i)  // en.wikipedia.org/wiki/LEB128
  loop
    breakif i < 128
    emitByte(128 + (i mod 128))
    i := i / 128  
  endloop
  emitByte(i)
endfun

fun emitSleb(i32 i)
  if i >= 0 then 
    loop
      breakif i < 64
      emitByte(128 + (i mod 128))
      i := i / 128
    endloop
    emitByte(i)
  else
    loop
      breakif i >= -64
      emitByte((i mod 128) - 128)
      i := i / 128
    endloop
    emitByte(i - 128)
  endif
endfun

fun emitSleb64(i64 i)
  if i >= 0 then 
    loop
      breakif i < 64
      emitByte(i64_i32(128 + (i mod 128)))
      i := i / 128
    endloop
    emitByte(i64_i32(i))
  else
    loop
      breakif i >= -64
      emitByte(i64_i32((i mod 128) - 128))
      i := i / 128
    endloop
    emitByte(i64_i32(i - 128))
  endif
endfun

fun fixUlebGuess(ptr Start, i32 offset)
  ptr Copy := BinaryPointer
  if offset > 0 then
    loop
      Copy := Copy - 1
      breakif Copy < Start
      store8(Copy + offset, load8u(Copy))
    endloop
  endif
endfun

fun emitType(ptr Node)
  ptr ParamList := Node.node_ParamNodes
  emitByte(0x60)  // fun type
  emitUleb(ParamList.list_count)
  ptr ParamItem := ParamList.list_First
  loop
    breakif not ParamItem
    i32 dataType := ParamItem.item_Object.node_type
    if dataType = tokens_bool or dataType = tokens_ptr then 
      emitByte(tokens_i32)
    else
      emitByte(dataType)
    endif    
    ParamItem := ParamItem.item_Next
  endloop
  i32 returnType := Node.node_type
  if returnType then
    emitByte(0x01)  // return count
    if returnType = tokens_bool or returnType = tokens_ptr then 
      emitByte(tokens_i32)
    else
      emitByte(returnType)
    endif
  else
    emitByte(0x00)  // return count
  endif
endfun

fun emitTypeSection()
  ptr BodyList := RootNode.node_Nodes
  ptr Skip := BinaryPointer
  if BodyList then
    if BodyList.list_count then
      emitByte(0x01)  // Type section
      emitByte(0x00)  // section size (guess)
      ptr Start := BinaryPointer 
      emitByte(0x00)  // types count (guess)  
      i32 count := 0
      i32 Item := BodyList.list_First
      loop
        i32 Node := Item.item_Object
        if Node.node_kind = nodes_fun then
          emitType(Node)
          count := count + 1
          emitFunCount := emitFunCount + 1
        endif
        Item := Item.item_Next
        breakif not Item
      endloop
      i32 length := BinaryPointer - Start
      i32 offset := uLebLen(count) - 1 + uLebLen(length) - 1
      fixUlebGuess(Start, offset)
      BinaryPointer := Start - 1
      emitUleb(length + uLebLen(count) - 1)
      emitUleb(count)
      BinaryPointer := BinaryPointer + length - 1
    endif
  endif
  if not emitFunCount then BinaryPointer := Skip endif
endfun

fun emitFunctionSection()
  if emitFunCount then
    emitByte(0x03)  // Function section
    emitByte(0x00)  // section size (guess)
    ptr Start := BinaryPointer 
    emitUleb(emitFunCount)  // types count
    i32 counter := 0
    loop
      breakif counter >= emitFunCount
      emitUleb(counter)
      counter := counter + 1
    endloop
    i32 length := BinaryPointer - Start
    i32 offset := uLebLen(length) - 1
    fixUlebGuess(Start, offset)
    BinaryPointer := Start - 1
    emitUleb(length)
    BinaryPointer := BinaryPointer + length
  endif
endfun

fun emitMemorySection()
  if memMin or memMax then
    emitByte(0x05)  // Memory section
    if memMax then
      if memMax < memMin then memMax := memMin endif
      emitUleb(2 + uLebLen(memMin) + uLebLen(memMax))  // Size in bytes
      emitByte(0x01)    // Count. A maximum of 1 currently in WebAssembly
      emitByte(0x01)    // Resizable
      emitUleb(memMin)  // Pages
      emitUleb(memMax)  // Pages
    else
      emitUleb(2 + uLebLen(memMin))  // Size in bytes
      emitByte(0x01)    // Count
      emitByte(0x00)    // Resizable
      emitUleb(memMin)  // Pages
    endif
  endif
endfun

fun emitNativeGlobal(i32 Node)
  i32 dataType := Node.node_type  // Native type
  if dataType = tokens_f64 then 
    emitByte(dataType)
    emitByte(0x01)  // Mutable
    emitByte(0x44)  // f64.const
  elseif dataType = tokens_f32 then 
    emitByte(dataType)
    emitByte(0x01)  // Mutable
    emitByte(0x43)  // f32.const
  elseif dataType = tokens_i64 then
    emitByte(dataType)
    emitByte(0x01)  // Mutable
    emitByte(0x42)  // i64.const
  else  // i32, bool, ptr
    emitByte(tokens_i32)
    emitByte(0x01)  // Mutable
    emitByte(0x41)  // i32.const
  endif
  i32 Value := Node.node_BNode.node_String
  i32 nodeType := Node.node_BNode.node_type
  if nodeType = tokens_true then
    emitByte(0x01) 
  elseif nodeType = tokens_false then 
    emitByte(0x00) 
  elseif dataType = tokens_f64 then
    emitF64(strToF64(Value))
  elseif dataType = tokens_f32 then
    emitF32(strToF32(Value))
  elseif dataType = tokens_i64 then
    emitSleb64(strToI64(Value))
  else
    emitSleb(strToI32(Value))
  endif
  emitByte(0x0b)  // end
endfun

fun emitGlobalSection()
  ptr BodyList := RootNode.node_Nodes
  ptr Skip := BinaryPointer
  if BodyList then
    if BodyList.list_count then
      emitByte(0x06)  // Section code
      emitByte(0x00)  // Section size (guess)
      ptr Start := BinaryPointer 
      emitByte(0x00)  // Globals count (guess)
      ptr Item := BodyList.list_First
      i32 count := 0
      loop
        ptr Node := Item.item_Object
        if Node.node_kind = nodes_variable then
          emitNativeGlobal(Node)
          count := count + 1
          emitGlobalCount := emitGlobalCount + 1
        endif
        Item := Item.item_Next
        breakif not Item
      endloop
      i32 length := BinaryPointer - Start
      i32 offset := uLebLen(count) - 1 + uLebLen(length) - 1
      fixUlebGuess(Start, offset)
      BinaryPointer := Start - 1
      emitUleb(length + uLebLen(count) - 1)
      emitUleb(count)
      BinaryPointer := BinaryPointer + length - 1
    endif
  endif
  if not emitGlobalCount then BinaryPointer := Skip endif
endfun

fun emitExportFuns()
  ptr Item := ExportList.list_First
  loop
    ptr Name := Item.item_Name
    emitUleb(Name.string_length)
    emitString(Name)
    emitByte(0x00)  // Type: function
    emitUleb(Item.item_Object.node_index)
    Item := Item.item_Next
    breakif not Item
  endloop
endfun

fun emitExportMem()
  emitUleb(MemExport.string_length)
  emitString(MemExport)
  emitByte(0x02)  // Type: memory
  emitByte(0x00)  // Memory number 0 
endfun

fun emitExportSection()
  ptr BodyList := RootNode.node_Nodes
  if BodyList then
    i32 count := ExportList.list_count
    if MemExport then count := count + 1 endif
    if count then
      emitByte(0x07)  // Export section
      emitByte(0x00)  // Section size (guess)
      ptr Start := BinaryPointer
      emitUleb(count)  // Export count
      if MemExport then
        emitExportMem()
      endif
      if ExportList.list_count then
        emitExportFuns()
      endif
      i32 length := BinaryPointer - Start
      i32 offset := uLebLen(length) - 1
      fixUlebGuess(Start, offset)
      BinaryPointer := Start - 1
      emitUleb(length)
      BinaryPointer := BinaryPointer + length
    endif
  endif
endfun

fun emitAssignment(ptr Node)
  ptr ResolvedNode := ScopeResolve(CurrentScope, Node.node_ANode.node_String)
  i32 dataType := ResolvedNode.node_type
  ptr BNode := Node.node_BNode
  Node.node_dataType := dataType
  BNode.node_dataType := dataType
  emitNode(BNode)
  if ResolvedNode.node_Scope = GlobalScope then
    emitByte(0x24)  // set_global
  else
    emitByte(0x21)  // set_local
  endif
  emitUleb(ResolvedNode.node_index)
endfun

fun emitOperator(i32 type, i32 dataType)
  if dataType = tokens_f64 then
    if type = tokens_eq    then emitByte(0x61) endif
    if type = tokens_ne    then emitByte(0x62) endif
    if type = tokens_lt    then emitByte(0x63) endif
    if type = tokens_gt    then emitByte(0x64) endif
    if type = tokens_le    then emitByte(0x65) endif
    if type = tokens_ge    then emitByte(0x66) endif
    if type = tokens_abs   then emitByte(0x99) endif
    if type = tokens_neg   then emitByte(0x9a) endif
    if type = tokens_ceil  then emitByte(0x9b) endif
    if type = tokens_floor then emitByte(0x9c) endif
    if type = tokens_trunc then emitByte(0x9d) endif
    if type = tokens_round then emitByte(0x9e) endif
    if type = tokens_sqrt  then emitByte(0x9f) endif
    if type = tokens_add   then emitByte(0xa0) endif
    if type = tokens_sub   then emitByte(0xa1) endif
    if type = tokens_mul   then emitByte(0xa2) endif
    if type = tokens_div   then emitByte(0xa3) endif
    if type = tokens_min   then emitByte(0xa4) endif
    if type = tokens_max   then emitByte(0xa5) endif
    if type = tokens_copys then emitByte(0xa6) endif
  elseif dataType = tokens_f32 then
    if type = tokens_eq    then emitByte(0x5b) endif
    if type = tokens_ne    then emitByte(0x5c) endif
    if type = tokens_lt    then emitByte(0x5d) endif
    if type = tokens_gt    then emitByte(0x5e) endif
    if type = tokens_le    then emitByte(0x5f) endif
    if type = tokens_ge    then emitByte(0x60) endif
    if type = tokens_abs   then emitByte(0x8b) endif
    if type = tokens_neg   then emitByte(0x8c) endif
    if type = tokens_ceil  then emitByte(0x8d) endif
    if type = tokens_floor then emitByte(0x8e) endif
    if type = tokens_trunc then emitByte(0x8f) endif
    if type = tokens_round then emitByte(0x90) endif
    if type = tokens_sqrt  then emitByte(0x91) endif
    if type = tokens_add   then emitByte(0x92) endif
    if type = tokens_sub   then emitByte(0x93) endif
    if type = tokens_mul   then emitByte(0x94) endif
    if type = tokens_div   then emitByte(0x95) endif
    if type = tokens_min   then emitByte(0x96) endif
    if type = tokens_max   then emitByte(0x97) endif
    if type = tokens_copys then emitByte(0x98) endif
  elseif dataType = tokens_i64 then
    if type = tokens_not  then emitByte(0x50) endif
    if type = tokens_eq   then emitByte(0x51) endif
    if type = tokens_ne   then emitByte(0x52) endif
    if type = tokens_lt   then emitByte(0x53) endif
    if type = tokens_ltu  then emitByte(0x54) endif
    if type = tokens_gt   then emitByte(0x55) endif
    if type = tokens_gtu  then emitByte(0x56) endif
    if type = tokens_le   then emitByte(0x57) endif
    if type = tokens_leu  then emitByte(0x58) endif
    if type = tokens_ge   then emitByte(0x59) endif
    if type = tokens_geu  then emitByte(0x5a) endif
    if type = tokens_clz  then emitByte(0x79) endif
    if type = tokens_ctz  then emitByte(0x7a) endif
    if type = tokens_cnt  then emitByte(0x7b) endif
    if type = tokens_add  then emitByte(0x7c) endif
    if type = tokens_sub  then emitByte(0x7d) endif
    if type = tokens_mul  then emitByte(0x7e) endif
    if type = tokens_div  then emitByte(0x7f) endif
    if type = tokens_divu then emitByte(0x80) endif
    if type = tokens_mod  then emitByte(0x81) endif
    if type = tokens_modu then emitByte(0x82) endif
    if type = tokens_and  then emitByte(0x83) endif
    if type = tokens_or   then emitByte(0x84) endif
    if type = tokens_xor  then emitByte(0x85) endif
    if type = tokens_shl  then emitByte(0x86) endif
    if type = tokens_shr  then emitByte(0x87) endif
    if type = tokens_shru then emitByte(0x88) endif
    if type = tokens_rotl then emitByte(0x89) endif
    if type = tokens_rotr then emitByte(0x8a) endif
  else
    if type = tokens_not  then emitByte(0x45) endif
    if type = tokens_eq   then emitByte(0x46) endif
    if type = tokens_ne   then emitByte(0x47) endif
    if type = tokens_lt   then emitByte(0x48) endif
    if type = tokens_ltu  then emitByte(0x49) endif
    if type = tokens_gt   then emitByte(0x4a) endif
    if type = tokens_gtu  then emitByte(0x4b) endif
    if type = tokens_le   then emitByte(0x4c) endif
    if type = tokens_leu  then emitByte(0x4d) endif
    if type = tokens_ge   then emitByte(0x4e) endif
    if type = tokens_geu  then emitByte(0x4f) endif
    if type = tokens_clz  then emitByte(0x67) endif
    if type = tokens_ctz  then emitByte(0x68) endif
    if type = tokens_cnt  then emitByte(0x69) endif
    if type = tokens_add  then emitByte(0x6a) endif
    if type = tokens_sub  then emitByte(0x6b) endif
    if type = tokens_mul  then emitByte(0x6c) endif
    if type = tokens_div  then emitByte(0x6d) endif
    if type = tokens_divu then emitByte(0x6e) endif
    if type = tokens_mod  then emitByte(0x6f) endif
    if type = tokens_modu then emitByte(0x70) endif
    if type = tokens_and  then emitByte(0x71) endif
    if type = tokens_or   then emitByte(0x72) endif
    if type = tokens_xor  then emitByte(0x73) endif
    if type = tokens_shl  then emitByte(0x74) endif
    if type = tokens_shr  then emitByte(0x75) endif
    if type = tokens_shru then emitByte(0x76) endif
    if type = tokens_rotl then emitByte(0x77) endif
    if type = tokens_rotr then emitByte(0x78) endif
  endif
endfun

fun emitUnary(ptr Node)
  i32 type := Node.node_type
  i32 dataType := Node.node_dataType
  if type = tokens_sub then
    if dataType = tokens_f64 then
      emitByte(0x44)  // f64.const
      emitF64(0) 
    elseif dataType = tokens_f32 then
      emitByte(0x43)  // f32.const
      emitF32(0) 
    elseif dataType = tokens_i64 then
      emitByte(0x42)  // i64.const 
      emitByte(0x00)  // 0
    else
      emitByte(0x41)  // i32.const 
      emitByte(0x00)  // 0
    endif
  endif
  emitNode(Node.node_BNode)
  emitOperator(type, dataType)
endfun

fun emitIdentifier(ptr Node)
  ptr ResolvedNode := ScopeResolve(CurrentScope, Node.node_String)
  i32 dataType := ResolvedNode.node_dataType
  if dataType then
    Node.node_dataType := dataType
  endif
  if ResolvedNode.node_Scope = GlobalScope then
    emitByte(0x23)  // get_global
  else
    emitByte(0x20)  // get_local
  endif
  emitUleb(ResolvedNode.node_index)
endfun

// A.B.C.D
// loadX(load(load(A + B) + C) + D)
// A B + load() C + load() D + loadX()
fun emitDotLoad(ptr Node)
  i32 dataType := Node.node_dataType
  ptr IdentList := Node.node_Nodes
  i32 Item := IdentList.list_First
  i32 itemCount := IdentList.list_count
  i32 itemNo := 1
  emitIdentifier(Item.item_Object)
  Item := Item.item_Next
  loop
    breakif not Item
    itemNo := itemNo + 1
    emitIdentifier(Item.item_Object)
    emitByte(0x6a)  // i32.add
    if itemNo < itemCount then
      emitByte(0x28)  // i32.load
    else
      if dataType = tokens_f64 then
        emitByte(0x2b)  // f64.load
      elseif dataType = tokens_f32 then
        emitByte(0x2a)  // f32.load
      elseif dataType = tokens_i64 then
        emitByte(0x29)  // i64.load
      else
        emitByte(0x28)  // i32.load
      endif
    endif
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
    Item := Item.item_Next
  endloop
endfun

// A.B.C.D := x
// storeX(load(load(A + B) + C) + D, x)
// A B + load() C + load() D + x storeX()
fun emitDotStore(ptr Node)
  i32 dataType := Node.node_dataType
  if not dataType then
    dataType := inferDataType(Node.node_ANode)
    Node.node_dataType := dataType
  endif
  ptr IdentList := Node.node_Nodes
  i32 Item := IdentList.list_First
  i32 itemCount := IdentList.list_count
  i32 itemNo := 1
  emitIdentifier(Item.item_Object)
  Item := Item.item_Next
  loop
    breakif not Item
    itemNo := itemNo + 1
    emitIdentifier(Item.item_Object)
    emitByte(0x6a)  // i32.add
    if itemNo < itemCount then
      emitByte(0x28)  // i32.load
    else
      emitNode(Node.node_ANode)
      if dataType = tokens_f64 then
        emitByte(0x39)  // f64.store
      elseif dataType = tokens_f32 then
        emitByte(0x38)  // f32.store
      elseif dataType = tokens_i64 then
        emitByte(0x37)  // i64.store
      else
        emitByte(0x36)  // i32.store
      endif
    endif
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
    Item := Item.item_Next
  endloop
endfun

fun emitNumLiteral(ptr Node, i32 dataType)
  if dataType = tokens_f64 then
    emitByte(0x44)  // f64.const
    emitF64(strToF64(Node.node_String))
  elseif dataType = tokens_f32 then
    emitByte(0x43)  // f32.const
    emitF32(strToF32(Node.node_String))
  elseif dataType = tokens_i64 then
    emitByte(0x42)  // i64.const
    emitSleb64(strToI64(Node.node_String))
  else
    emitByte(0x41)  // i32.const
    emitSleb(strToI32(Node.node_String))
  endif
endfun

fun emitCharLiteral(ptr Node, i32 dataType)
  ptr Name := Node.node_String
  if dataType = tokens_i64 then
    emitByte(0x42)  // i64.const
    if Name.string_length > 4 then
      emitSleb64(load64(Name + string_Chars))
    else
      emitSleb(Name.string_Chars)
    endif
  else
    emitByte(0x41)  // i32.const
    emitSleb(Name.string_Chars)
  endif
endfun

fun emitLiteral(ptr Node)
  i32 type := Node.node_type
  i32 dataType := Node.node_dataType
  if type = tokens_numLiteral then
    emitNumLiteral(Node, dataType)
  elseif type = tokens_charLiteral then
    emitCharLiteral(Node, dataType)
  elseif type = tokens_true then
    emitByte(0x41)  // i32.const
    emitByte(0x01)  // 1
  elseif type = tokens_false then
    emitByte(0x41)  // i32.const
    emitByte(0x00)  // 0
  endif
endfun

fun emitFunCallArguments(ptr CallNode, ptr FunNode)
  ptr ArgumentList := CallNode.node_ParamNodes
  ptr ArgumentItem := ArgumentList.list_First
  ptr ParamList := FunNode.node_ParamNodes
  ptr ParamItem := ParamList.list_First
  loop
    breakif not ArgumentItem
    ptr ArgumentNode := ArgumentItem.item_Object
    ptr ParamNode := ParamItem.item_Object
    ArgumentNode.node_dataType := ParamNode.node_dataType
    emitNode(ArgumentNode)
    ArgumentItem := ArgumentItem.item_Next
    ParamItem := ParamItem.item_Next
  endloop
endfun

fun emitCallArguments(ptr CallNode, i32 data_Type)
  ptr ArgumentList := CallNode.node_ParamNodes
  ptr ArgumentItem := ArgumentList.list_First
  loop
    breakif not ArgumentItem
    ptr ArgumentNode := ArgumentItem.item_Object
    ArgumentNode.node_dataType := data_Type
    emitNode(ArgumentNode)
    ArgumentItem := ArgumentItem.item_Next
  endloop
endfun

fun emitCallArguments2(ptr CallNode, i32 data_TypeA, i32 data_TypeB)
  ptr ArgumentList := CallNode.node_ParamNodes
  ptr ArgumentItem := ArgumentList.list_First
  bool isFirst := true
  loop
    breakif not ArgumentItem
    ptr ArgumentNode := ArgumentItem.item_Object
    if isFirst then
      ArgumentNode.node_dataType := data_TypeA
    else    
      ArgumentNode.node_dataType := data_TypeB
    endif
    emitNode(ArgumentNode)
    ArgumentItem := ArgumentItem.item_Next
    isFirst := false
  endloop
endfun

fun emitCall(ptr Node)
  ptr Name := Node.node_ANode.node_String
  if strCompare64(Name, 'i64_i32') then
    emitCallArguments(Node, tokens_i64)
    emitByte(0xa7)  // i32.wrap/i64
  elseif strCompare64(Name, 'f32_i32') then
    emitCallArguments(Node, tokens_f32)
    emitByte(0xa8)  // i32.trunc_s/f32
  elseif strCompare64(Name, 'f32_i32u') then
    emitCallArguments(Node, tokens_f32)
    emitByte(0xa9)  // i32.trunc_u/f32
  elseif strCompare64(Name, 'f64_i32') then
    emitCallArguments(Node, tokens_f64)
    emitByte(0xaa)  // i32.trunc_s/f64
  elseif strCompare64(Name, 'f64_i32u') then
    emitCallArguments(Node, tokens_f64)
    emitByte(0xab)  // i32.trunc_u/f64
  elseif strCompare64(Name, 'i32_i64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0xac)  // i64.extend_s/i32
  elseif strCompare64(Name, 'i32_i64u') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0xad)  // i64.extend_u/i32
  elseif strCompare64(Name, 'f32_i64') then
    emitCallArguments(Node, tokens_f32)
    emitByte(0xae)  // i64.trunc_s/f32
  elseif strCompare64(Name, 'f32_i64u') then
    emitCallArguments(Node, tokens_f32)
    emitByte(0xaf)  // i64.trunc_u/f32
  elseif strCompare64(Name, 'f64_i64') then
    emitCallArguments(Node, tokens_f64)
    emitByte(0xb0)  // i64.trunc_s/f64
  elseif strCompare64(Name, 'f64_i64u') then
    emitCallArguments(Node, tokens_f64)
    emitByte(0xb1)  // i64.trunc_u/f64
  elseif strCompare64(Name, 'i32_f32') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0xb2)  // f32.convert_s/i32    
  elseif strCompare64(Name, 'i32_f32u') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0xb3)  // f32.convert_u/i32   
  elseif strCompare64(Name, 'i64_f32') then
    emitCallArguments(Node, tokens_i64)
    emitByte(0xb4)  // f32.convert_s/i64
  elseif strCompare64(Name, 'i64_f32u') then
    emitCallArguments(Node, tokens_i64)
    emitByte(0xb5)  // f32.convert_u/i64
  elseif strCompare64(Name, 'f64_f32') then
    emitCallArguments(Node, tokens_f64)
    emitByte(0xb6)  // f32.demote/f64
  elseif strCompare64(Name, 'i32_f64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0xb7)  // f64.convert_s/i32
  elseif strCompare64(Name, 'i32_f64u') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0xb8)  // f64.convert_u/i32
  elseif strCompare64(Name, 'i64_f64') then
    emitCallArguments(Node, tokens_i64)
    emitByte(0xb9)  // f64.convert_s/i64
  elseif strCompare64(Name, 'i64_f64u') then
    emitCallArguments(Node, tokens_i64)
    emitByte(0xba)  // f64.convert_u/i64
  elseif strCompare64(Name, 'f32_f64') then
    emitCallArguments(Node, tokens_f32)
    emitByte(0xbb)  // f64.promote/f32
  elseif strCompare64(Name, 'load32') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x28)  // i32.load
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'load64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x29)  // i64.load
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'loadf32') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x2a)  // f32.load
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'loadf64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x2b)  // f64.load
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'load8') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x2c)  // i32.load8_s
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'load8u') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x2d)  // i32.load8_u
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'load16') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x2e)  // i32.load16_s
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'load16u') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x2f)  // i32.load16_u
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'loa8i64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x30)  // i64.load8_s
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'loa8u64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x31)  // i64.load8_u
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'loa16i64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x32)  // i64.load16_s
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset    
  elseif strCompare64(Name, 'loa16u64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x33)  // i64.load16_u
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset 
  elseif strCompare64(Name, 'loa32i64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x34)  // i64.load32_s
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset    
  elseif strCompare64(Name, 'loa32u64') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x35)  // i64.load32_u
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset    
  elseif strCompare64(Name, 'store32') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x36)  // i32.store
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'store64') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    emitByte(0x37)  // i64.store
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'storeF32') then
    emitCallArguments2(Node, tokens_i32, tokens_f32)
    emitByte(0x38)  // f32.store
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'storeF64') then
    emitCallArguments2(Node, tokens_i32, tokens_f64)
    emitByte(0x39)  // f64.store
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'store8') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x3a)  // i32.store8
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'store16') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x3b)  // i32.store16
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'i64sto8') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    emitByte(0x3c)  // i64.store8
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'i64sto16') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    emitByte(0x3d)  // i64.store16
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'i64sto32') then
    emitCallArguments2(Node, tokens_i32, tokens_i64)
    emitByte(0x3e)  // i64.store32
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strCompare64(Name, 'memsize') then
    emitByte(0x3f)  // current_memory
    emitByte(0x00)  // memory number
  elseif strCompare64(Name, 'memgrow') then
    emitCallArguments(Node, tokens_i32)
    emitByte(0x40)  // grow_memory
    emitByte(0x00)  // memory number
  else
    ptr ResolvedNode := ScopeResolve(CurrentScope, Name)
    emitFunCallArguments(Node, ResolvedNode)
    emitByte(0x10)  // call
    emitUleb(ResolvedNode.node_index)
  endif
endfun

fun emitBlock(ptr Node)
  ptr Scope := Node.node_Scope
  CurrentScope := Scope
  ptr BlockList := Node.node_Nodes
  ptr Item := BlockList.list_First
  loop
    breakif not Item
    emitNode(Item.item_Object)
    Item := Item.item_Next
  endloop
  CurrentScope := Scope.scope_Parent
endfun

fun emitIf(ptr Node)
  emitNode(Node.node_CNode)  // If condition expression
  emitByte(0x04)  // if
  emitByte(0x40)  // void
  emitNode(Node.node_ANode)  // Then block
  ptr ElseBlock := Node.node_BNode
  if ElseBlock then
    emitByte(0x05)  // else
    emitNode(ElseBlock)
  endif
  emitByte(0x0b)  // end
endfun

fun i32 scopeLevel(ptr Node, i32 kind) 
  ptr Scope := Node.node_Scope
  i32 level := 0
  loop
    breakif not Scope
    breakif Scope.scope_Node.node_kind = kind
    level := level + 1
    Scope := Scope.scope_Parent
  endloop
  return level
endfun

fun emitLoop(ptr Node)
  emitByte(0x02)  // block
  emitByte(0x40)  // void 
  emitByte(0x03)  // loop
  emitByte(0x40)  // void 
  emitNode(Node.node_ANode)
  emitByte(0x0c)  // br
  emitByte(0x00)  // level 
  emitByte(0x0b)  // end
  emitByte(0x0b)  // end
endfun

fun i32 inferCallDataType(ptr Node)
  ptr Name := Node.node_String
  if     strCompare64(Name, 'load64')   then return tokens_i64
  elseif strCompare64(Name, 'load32')   then return tokens_i32
  elseif strCompare64(Name, 'load8')    then return tokens_i32
  elseif strCompare64(Name, 'load8u')   then return tokens_i32
  elseif strCompare64(Name, 'memsize')  then return tokens_i32
  elseif strCompare64(Name, 'loa_f32')  then return tokens_f32
  elseif strCompare64(Name, 'loa_f64')  then return tokens_f64
  elseif strCompare64(Name, 'f32_i32')  then return tokens_i32
  elseif strCompare64(Name, 'f32_i32u') then return tokens_i32
  elseif strCompare64(Name, 'f64_i32')  then return tokens_i32
  elseif strCompare64(Name, 'f64_i32u') then return tokens_i32
  elseif strCompare64(Name, 'i32_i64')  then return tokens_i64
  elseif strCompare64(Name, 'i32_i64u') then return tokens_i64
  elseif strCompare64(Name, 'f32_i64')  then return tokens_i64
  elseif strCompare64(Name, 'f32_i64u') then return tokens_i64
  elseif strCompare64(Name, 'f64_i64')  then return tokens_i64
  elseif strCompare64(Name, 'f64_i64u') then return tokens_i64
  elseif strCompare64(Name, 'i32_f32')  then return tokens_f32
  elseif strCompare64(Name, 'i32_f32u') then return tokens_f32
  elseif strCompare64(Name, 'i64_f32')  then return tokens_f32
  elseif strCompare64(Name, 'i64_f32u') then return tokens_f32
  elseif strCompare64(Name, 'f64_f32')  then return tokens_f32
  elseif strCompare64(Name, 'i32_f64')  then return tokens_f64
  elseif strCompare64(Name, 'i32_f64u') then return tokens_f64
  elseif strCompare64(Name, 'i64_f64')  then return tokens_f64
  elseif strCompare64(Name, 'i64_f64u') then return tokens_f64
  elseif strCompare64(Name, 'f32_f64')  then return tokens_f64
  else
    ptr ResolvedNode := ScopeResolve(CurrentScope, Name)
    return ResolvedNode.node_dataType
  endif
  return 0
endfun

fun i32 inferDataType(ptr Node)
  i32 dataType := Node.node_dataType
  i32 kind := Node.node_kind
  if kind = nodes_binary then
    dataType := inferDataType(Node.node_ANode)
    if not dataType then
      dataType := inferDataType(Node.node_BNode)
    endif
  elseif kind = nodes_identifier then
    ptr ResolvedNode := ScopeResolve(CurrentScope, Node.node_String)
    dataType := ResolvedNode.node_dataType
  elseif kind = nodes_unary then
    dataType := inferDataType(Node.node_BNode)
  elseif kind = nodes_call then
    dataType := inferCallDataType(Node.node_ANode)
  endif
  return dataType
endfun

fun emitBinary(ptr Node)
  i32 type := Node.node_type
  if type = tokens_assign then
    emitAssignment(Node)
  else
    i32 dataType := Node.node_dataType
    ptr ANode := Node.node_ANode
    ptr BNode := Node.node_BNode
    if not dataType then
      dataType := inferDataType(Node)
      Node.node_dataType := dataType
    endif
    ANode.node_dataType := dataType
    BNode.node_dataType := dataType
    emitNode(ANode)
    emitNode(BNode)
    emitOperator(type, dataType)
  endif
endfun

fun emitVariable(ptr Node)
  i32 type := Node.node_type
  ptr BNode := Node.node_BNode
  BNode.node_dataType := type
  emitNode(BNode)
  emitByte(0x21)  // set_local
  emitUleb(Node.node_index)
endfun

fun emitReturn(ptr Node)
  ptr ANode := Node.node_ANode
  i32 dataType := CurrentFunNode.node_dataType
  Node.node_dataType := dataType
  ANode.node_dataType := dataType
  emitNode(ANode)
  if scopeLevel(Node, nodes_fun) > 0 then
    emitByte(0x0f)  // return
  endif
endfun

fun emitBreakif(ptr Node)
  emitNode(Node.node_CNode)  // If condition expression
  emitByte(0x0d)  // br_if
  emitUleb(scopeLevel(Node, nodes_loop) + 1)
endfun

fun emitNode(ptr Node)
  i32 kind := Node.node_kind
  if     kind = nodes_block      then emitBlock(Node)
  elseif kind = nodes_binary     then emitBinary(Node)
  elseif kind = nodes_unary      then emitUnary(Node)
  elseif kind = nodes_call       then emitCall(Node)
  elseif kind = nodes_return     then emitReturn(Node)
  elseif kind = nodes_if         then emitIf(Node)
  elseif kind = nodes_breakif    then emitBreakif(Node)
  elseif kind = nodes_loop       then emitLoop(Node)
  elseif kind = nodes_hexwasm    then emitByte(Node.node_type)
  elseif kind = nodes_literal    then emitLiteral(Node)
  elseif kind = nodes_identifier then emitIdentifier(Node)
  elseif kind = nodes_dotLoad    then emitDotLoad(Node)
  elseif kind = nodes_dotStore   then emitDotStore(Node)
  elseif kind = nodes_variable   then emitVariable(Node)
  elseif kind = nodes_continue then
    emitByte(0x0c)  // br
    emitUleb(scopeLevel(Node, nodes_loop))
  elseif kind = nodes_break then
    emitByte(0x0c)  // br
    emitUleb(scopeLevel(Node, nodes_loop) + 1)
  endif
endfun

fun emitFunNode(ptr Node)
  CurrentFunNode := Node
  emitByte(0x00)  // Function size (guess)
  ptr Start := BinaryPointer
  ptr LocalList := Node.node_Nodes
  emitUleb(LocalList.list_count)
  ptr LocalItem := LocalList.list_First
  loop
    breakif not LocalItem
    emitByte(0x01)  // count
    i32 dataType := LocalItem.item_Object.node_type
    if dataType = tokens_bool or dataType = tokens_ptr then
      emitByte(tokens_i32)
    else
      emitByte(dataType)
    endif
    LocalItem := LocalItem.item_Next
  endloop
  emitNode(Node.node_ANode)  // Body block node
  emitByte(0x0b)  // end
  i32 length := BinaryPointer - Start
  i32 offset := uLebLen(length) - 1
  fixUlebGuess(Start, offset)
  BinaryPointer := Start - 1
  emitUleb(length)
  BinaryPointer := BinaryPointer + length
endfun

fun emitCodeSection()
  if emitFunCount then
    emitByte(0x0a)  // Code section
    emitByte(0x00)  // Section size (guess)
    ptr Start := BinaryPointer 
    emitUleb(emitFunCount)
    ptr FunItem := RootNode.node_Nodes.list_First
    loop
      ptr FunNode := FunItem.item_Object
      if FunNode.node_kind = nodes_fun then
        emitFunNode(FunNode)
      endif
      FunItem := FunItem.item_Next
      breakif not FunItem
    endloop
    i32 length := BinaryPointer - Start
    i32 offset := uLebLen(length) - 1
    fixUlebGuess(Start, offset)
    BinaryPointer := Start - 1
    emitUleb(length)
    BinaryPointer := BinaryPointer + length
  endif
endfun

fun emitDataSection()
  i32 count := DataList.list_count
  if count then
    emitByte(0x0b)  // Code section
    emitByte(0x00)  // Section size (guess)
    ptr Start := BinaryPointer 
    emitUleb(count)
    ptr DataItem := DataList.list_First
    loop
      emitByte(0x00)  // memory index 
      emitByte(0x41)  // i32.const
      emitUleb(strToI32(DataItem.item_Object.token_Value))  // offset
      emitByte(0x0b)  // end
      ptr DataString := DataItem.item_Name.token_Value
      i32 dataLength := DataString.string_length
      emitUleb(dataLength)
      i32 i := 0
      loop
        breakif i >= dataLength
        emitByte(getChar(DataString, i))
        i := i + 1
      endloop
      DataItem := DataItem.item_Next
      breakif not DataItem
    endloop
    i32 length := BinaryPointer - Start
    i32 offset := uLebLen(length) - 1
    fixUlebGuess(Start, offset)
    BinaryPointer := Start - 1
    emitUleb(length)
    BinaryPointer := BinaryPointer + length
  endif
endfun

fun emit(i32 length)
  CompilerOutput := NewString(length + 256)  // Heuristic: binary will be smaller than length(source) + 256
  BinaryPointer := CompilerOutput + string_Chars
  CurrentScope := RootNode.node_Scope
  emitByte(0x00)  // Wasm magic: 00 61 73 6d
  emitByte(0x61)  // a
  emitByte(0x73)  // s
  emitByte(0x6d)  // m
  emitI32(1)      // Wasm version
  emitTypeSection()
  emitFunctionSection()
  emitMemorySection()
  emitGlobalSection()
  emitExportSection()
  emitCodeSection()
  emitDataSection()
  CompilerOutput.string_length := BinaryPointer - (CompilerOutput + string_Chars)  // Fix up the length
endfun

// Pierre Rossouw 2017 
// https://github.com/PierreRossouw/dwasm
