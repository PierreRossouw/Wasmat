// Decompile.dwasm v0.0.20170809
// Converts wasm binaries to dwasm

memory 100 export "mem"

data 8 "\8c"  // binary length
data 12  // Source binary to decompile
"\00\61\73\6d\01\00\00\00\01\05\01\60\00\01\7f\03\02\01\00\07\08\01\04\6d\61\69\6e\00\00\0a\6d\01\6b\04\01\7f\01\7f\01\7f\01\7f\41\01\21\00\41\00\21\01\41\a0\8d\06\21\02\02\40\03\40\20\02\41\01\4c\0d\01\41\02\21\03\02\40\03\40\20\03\20\02\4e\0d\01\20\02\20\03\6f\41\00\46\04\40\41\00\21\00\0c\02\0b\20\03\41\01\6a\21\03\0c\00\0b\0b\20\00\04\40\20\01\41\01\6a\21\01\0b\41\01\21\00\20\02\41\01\6b\21\02\0c\00\0b\0b\20\01\0b"

// Constants
i32 DEC0DE  = 557785600  // Magic number -0x00dec0de - used for debugging
i32 SIZEINT = 4  // 32 bit pointers

// Globals
ptr Source       = 0
ptr ErrorList    = 0
ptr Output       = 0
ptr RootNode     = 0
ptr CurrentScope = 0
ptr ExportList   = 0
ptr DataList     = 0
i32 offset       = 0

func emit() end
func parse() end
func ingestFuncSection() end
func ingestExportSection() end
func ingestCodeSection() end

func i32 main() export
  drop NewString(Source.string_length)
  ErrorList = NewList()
  RootNode = NewNode(nodes_program)
  ExportList = NewList()
  DataList = NewList()
  ingest()
  if ErrorList.list_count.i32 == 0 then 
    parse() 
  end
  if ErrorList.list_count.i32 == 0 then
    emit()
  end
  if ErrorList.list_count.i32 > 0 then
    parseErrorList()
  end
  return Output + string_length
end

func ingest()
  if Source.string_length.i32 < 8 then
    listAddError(ErrorList, 0, error_nomagic)
  else
    ingestHeader()
  end
  if Source.string_length.i32 > 8 then
    i32 sectionNo = ingestByte()
    if sectionNo = 1 then
      ingestTypeSection()
      sectionNo = nextSectionNo()
    end
    if sectionNo = 3 then
      ingestFuncSection()
      sectionNo = nextSectionNo()
    end
    if sectionNo = 7 then
      ingestExportSection()
      sectionNo = nextSectionNo()
    end
    if sectionNo = 10 then
      ingestCodeSection()
      sectionNo = nextSectionNo()
    end
  end
end

func ingestTypeSection() 
  i32 size = ingestULeb()
  i32 count = ingestULeb()
  i32 i = 0
  loop
    breakif i >= count
    ingestType(i)
    i = i + 1
  end
end

func ingestType(i32 i)
  expectByte(0x60)
  i32 count = ingestULeb()
  i32 ParamTypes = Substring(Source, offset, count)
  offset = offset + count
  count = ingestULeb()
  i32 ReturnTypes = Substring(Source, offset, count)
  offset = offset + count
end

////////////////////////////////////////////////////////////////////////////////////////////////////

func expectByte(i32 byte)
  if ingestByte() <> byte then
    listAddError(ErrorList, offset - 1, error_unexected)
  end
end

func i32 nextSectionNo()
  i32 sectionNo = -1
  if offset < Source.string_length then
    sectionNo = ingestByte()
  end
  return sectionNo
end

func ingestHeader() 
  if ingestI32() <> '\00asm' then
    listAddError(ErrorList, 0, error_nomagic)
  end
  if ingestI32() <> 1 then
    listAddError(ErrorList, 4, error_badversion)
  end
end

////////////////////////////////////////////////////////////////////////////////////////////////////
// Scoper

// Struct
i32 scope_dec0de     = 0   // debugging marker
i32 scope_Node       = 4
i32 scope_index      = 8
i32 scope_Parent     = 12
i32 scope_Symbols    = 16
i32 scope_localIndex = 20
i32 scope_size       = 24

func pushScope(i32 Node)
  i32 Scope = Alloc(scope_size)
  Scope.scope_dec0de = 3 - DEC0DE
  Scope.scope_Symbols = NewList()
  Scope.scope_Node = Node
  if CurrentScope then
    Scope.scope_index.i32 = CurrentScope.scope_index + 1
    Scope.scope_Parent = CurrentScope
  end
  Node.node_Scope = Scope
  CurrentScope = Scope
end

func popScope()
  CurrentScope = CurrentScope.scope_Parent
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Nodes

// Enums
i32 nodes_program    = 0x01  // root node
i32 nodes_fun        = 0x02
i32 nodes_block      = 0x03
i32 nodes_return     = 0x04
i32 nodes_variable   = 0x05
i32 nodes_parameter  = 0x06
i32 nodes_identifier = 0x07
i32 nodes_literal    = 0x08
i32 nodes_binary     = 0x09
i32 nodes_unary      = 0x0a
i32 nodes_call       = 0x0b
i32 nodes_if         = 0x0c
i32 nodes_loop       = 0x0d
i32 nodes_break      = 0x0e
i32 nodes_continue   = 0x0f
i32 nodes_hexwasm    = 0x10  // WebAssembly code byte e.g. tokens_nop
i32 nodes_breakif    = 0x11
i32 nodes_mem        = 0x12
i32 nodes_data       = 0x13
i32 nodes_dotLoad    = 0x14
i32 nodes_dotStore   = 0x15
i32 nodes_drop       = 0x16
i32 nodes_iif        = 0x17

// Structs
i32 node_dec0de     = 0   // debugging marker
i32 node_kind       = 4   // From the nodes_ enum
i32 node_index      = 8   // Zero based index number for funs, variables, parameters
i32 node_String     = 12  // Literal value, or fun/var/parameter name
i32 node_Scope      = 16  // Scope for program/block/loop/func used for name resolution
i32 node_ANode      = 20  // Binary left, call fun, return expression, then block, or func body
i32 node_BNode      = 24  // Binary/unary right, else block, func return, variable assignment
i32 node_CNode      = 28  // If statement condition node
i32 node_Nodes      = 32  // List of child nodes for program/block, or func locals
i32 node_ParamNodes = 36  // List of params for call/fun
i32 node_type       = 40  // From the tokens_ enum
i32 node_dataType   = 44  // inferred data type
i32 node_Token      = 48
i32 node_size       = 52

func ptr NewNode(i32 kind)
  ptr Node = Alloc(node_size)
  Node.node_Scope = CurrentScope
  Node.node_dec0de = 2 - DEC0DE
  Node.node_kind = kind
  return Node
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Ingest helper functions

func i32 ingestULeb()
  i32 i = 0
  i32 result = 0
  loop
    i = ingestByte()
    result = (result << 7) + (i mod 128)
    breakif i < 128
  end
  return result
end

func i32 ingestByte()
  i32 result = getChar(Source, offset)
  offset = offset + 1
  return result
end

func i32 ingestI32()
  i32 result = get32(Source, offset)
  offset = offset + 4
  return result
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Errors

// Enum
i32 error_nomagic    = 1
i32 error_badversion = 2
i32 error_unexected  = 3

func parseErrorList()
  ptr ErrorItem = ErrorList.list_First
  if ErrorItem then
    ptr ErrorString = NewEmptyString(1000)
    loop
      i32 errorNo = ErrorItem.item_errorNo
      if errorNo == error_nomagic then
        appendChar(ErrorString, 'No Wasm ')
        appendChar(ErrorString, 'magic')
      elseif errorNo == error_badversion then
        appendChar(ErrorString, 'Invalid ')
        appendChar(ErrorString, 'version')
      elseif errorNo == error_unexected then
        appendChar(ErrorString, 'Unexpect')
        appendChar(ErrorString, 'ed byte')        
      else  
        appendChar(ErrorString, 'Error ')
        appendI32(ErrorString, errorNo)
      end
      appendChar(ErrorString, ' index ')
      appendI32(ErrorString, ErrorItem.item_index)
      appendChar(ErrorString, 13)
      Output = ErrorString
      ErrorItem = ErrorItem.item_Next
      breakif not ErrorItem
    end
  end
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Lists

// Structs
i32 item_dec0de = 0  // debugging marker
i32 item_Next   = 4
i32 item_Object = 8    i32 item_index   = 8
i32 item_Name   = 12   i32 item_errorNo = 12
i32 item_number = 12
i32 item_size   = 16

i32 list_dec0de = 0  // debugging marker
i32 list_First  = 4
i32 list_Last   = 8
i32 list_count  = 12
i32 list_size   = 16

func ptr NewList()
  ptr List = Alloc(list_size)
  List.list_dec0de = 4 - DEC0DE
  return List
end

func listAdd(i32 List, i32 Object)
  i32 Item = Alloc(item_size)
  Item.item_dec0de = 5 - DEC0DE
  Item.item_Object = Object
  if not List.list_First.ptr then
    List.list_First = Item
  else
    List.list_Last.item_Next = Item
  end
  List.list_Last = Item
  List.list_count.i32 = List.list_count + 1
end

func listAddError(i32 List, i32 index, i32 errorNo)
  i32 Item = Alloc(item_size)
  Item.item_dec0de = 5 - DEC0DE
  Item.item_index = index
  Item.item_errorNo = errorNo
  if not List.list_First.i32 then
    List.list_First = Item
  else
    List.list_Last.item_Next = Item
  end
  List.list_Last = Item
  List.list_count.i32 = List.list_count + 1
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Memory management

ptr Heap = 0  // Next free memory

func ptr Alloc(i32 length)
  ptr NewMemory = Heap
  Heap = Heap + length
  if Heap mod SIZEINT then
    Heap = Heap + SIZEINT - Heap mod SIZEINT  // Fix the alignment
  end
  return NewMemory
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Strings

// Structs
i32 string_dec0de = 0
i32 string_max    = 4  // optional
i32 string_length = 8
i32 string_Chars  = 12
i32 string_size   = 16

// Pascal-style strings: We store the length instead of using a null terminator
func i32 NewString(i32 length)
  i32 String = Alloc(string_Chars + length)
  String.string_dec0de = 7 - DEC0DE
  String.string_max = length
  String.string_length = length
  return String
end

func i32 NewEmptyString(i32 maxLength)
  i32 String = Alloc(string_Chars + maxLength)
  String.string_dec0de = 7 - DEC0DE
  String.string_max = maxLength
  String.string_length = 0
  return String
end

func appendString(ptr String, ptr AppendString)
  i32 stringLength = String.string_length
  i32 appendLength = AppendString.string_length
  i32 maxLength = String.string_max
  i32 offset = 0
  if appendLength > 0 and stringLength < maxLength then
    loop
      setChar(String, stringLength, getChar(AppendString, offset))
      stringLength = stringLength + 1
      breakif stringLength >= maxLength
      offset = offset + 1
      breakif offset >= appendLength
    end
    String.string_length = stringLength
  end
end

func appendI32(ptr String, i32 i)
  i32 stringLength = String.string_length
  i32 appendLength = decimalStringLength(i)
  i32 maxLength = String.string_max
  i32 offset = appendLength
  if stringLength + appendLength <= maxLength then
    loop
      i32 chr = '0' + i mod 10
      offset = offset - 1
      setChar(String, stringLength + offset, chr)
      i = i / 10
      breakif not i
      breakif not offset 
    end  
    String.string_length = stringLength + appendLength
  end
end

func appendChar(ptr String, i64 i)
  i32 stringLength = String.string_length
  i32 appendLength = charStringLength(i)
  i32 maxLength = String.string_max
  i32 offset = 0
  if stringLength + appendLength <= maxLength then
    loop
      i32 chr = i64_i32(i mod 256)
      setChar(String, stringLength + offset, chr)
      offset = offset + 1
      i = i >>+ 8
      breakif i == 0
      breakif offset >= appendLength
    end  
    String.string_length = stringLength + appendLength
  end
end

func i32 charStringLength(i64 i)
  i32 length = 0
  loop
    breakif i == 0
    i = i >>+ 8
    length = length + 1
  end
  return length
end

func i32 decimalStringLength(i32 i)
  i32 length = 1
  loop
    i = i / 10
    breakif not i
    length = length + 1
  end
  return length
end

func i32 getChar(i32 String, i32 offset)
  return load8u(String + string_Chars + offset)
end

func i32 get32(i32 String, i32 offset)
  return load32(String + string_Chars + offset)
end

func setChar(i32 String, i32 offset, i32 chr)
  store8(String + string_Chars + offset, chr)
end

func i32 Substring(i32 String, i32 offset, i32 length)
  if offset >= String.string_length then
    length = 0
  end
  if offset + length >= String.string_length then
    length = String.string_length - offset
  end
  i32 R = NewString(length)
  loop
    breakif length == 0
    length = length - 1
    setChar(R, length, getChar(String, offset + length))
  end
  return R
end

func bool strEq(i32 A, i32 B)
  i32 length = A.string_length
  if length == B.string_length then
    i32 offset = 0
    loop
      if getChar(A, offset) <> getChar(B, offset) then
        return false
      end
      breakif offset >= length
      offset = offset + 1
    end
  else
    return false
  end
  return true
end

func bool strEqChar(i32 String, i64 a)
  i32 length = String.string_length
  if length > 8 then
    return false
  elseif length > 4 then
    if a <> load64(String + string_Chars) then return false end
  elseif length > 0 then
    if a <> i32_i64(load32(String + string_Chars)) then return false end
  elseif length = 0 then
    if a <> 0 then return false end
  end
  return true
end

func i32 hexCharToInt(i32 char)
  if char >= '0' and char <= '9' then
    return char - '0'
  elseif char >= 'a' and char <= 'f' then
    return char - 'a' + 10
  elseif char >= 'A' and char <= 'F' then
    return char - 'A' + 10
  end
  return 0
end

// Strings may contain escaped hex bytes for example "\5a" -> "Z"
func decodeString(i32 S)
  i32 length = S.string_length
  i32 i = 0
  i32 o = 0
  loop
    breakif i >= length
    if getChar(S, i) == 92 then // backslash
      i = i + 1
      if isNumber(getChar(S, i), true) and isNumber(getChar(S, i + 1), true) then
        i32 char = hexCharToInt(getChar(S, i)) 
        char = char * 16
        char = char + hexCharToInt(getChar(S, i + 1))
        setChar(S, o, char)
        i = i + 1
      end
    elseif i > o then
      setChar(S, o, getChar(S, i))
    end
    i = i + 1
    o = o + 1
  end
  S.string_length = o
  loop
    breakif o >= length
    setChar(S, o, 0)
    o = o + 1
  end
end

func bool isAlpha(i32 chr)
  return (chr >= 'a' and chr <= 'z') or (chr >= 'A' and chr <= 'Z') or (chr == '_')
end

func bool isNumber(i32 chr, bool hexNum)
  if chr >= '0' and chr <= '9' then
    return true
  elseif hexNum then
    if (chr >= 'a' and chr <= 'f') or (chr >= 'A' and chr <= 'F') then 
      return true 
    end
  end
  return false
end

// Pierre Rossouw 2017  https://github.com/PierreRossouw/dwasm
