<html>
  <head>
    <link href="prism.css" rel="stylesheet" />
  </head>
  <body>
    <h1>dWasm WebAssembly Compiler</h1>
    <table width="99%">
      <tr>
        <td width="70%">Compiler memory dump</td>
        <td>Compiler WebAssembly binary</td>
      </tr><tr>
        <td><textarea id="compilerLog"></textarea></td>
        <td><textarea id="compilerBinary"></textarea></td>
      </tr><tr>
        <td colspan="2" align="center"><button id="compile">Compile</button></td>
      </tr><tr>
        <td>Code to compile</td>
        <td>Compiled binary</td>
      </tr><tr>
        <td><textarea id="code">
         </textarea></td>
        <td><textarea id="binary"></textarea></td>
      </tr><tr>
        <td colspan="2" align="center"><button id="execute">Execute</button></td>
      </tr><tr>
        <td>Memory dump</td>
        <td>main() => <textarea id="execResult" style="height: 20; width: 100" ></textarea></td>
      </tr><tr>
        <td><textarea id="execMemDump"></textarea></td>
        <td><textarea id="execResultString"></textarea></td>
      </tr>
    </table>
    <pre><code id="compilerSource" class="language-c"></code></pre>
    <style>
      textarea {
        height: 300px;
        width: 100%;
      }
      pre {
        overflow: auto;
        font-size: 17px;
      }
    </style>
    <script src="prism.js"></script>
    <script>
      if (window.WebAssembly === void 0) {
        alert("Your browser doesn't support WebAssembly!");
      }

      var xmlhttp, text;
      xmlhttp = new XMLHttpRequest();
      xmlhttp.open('GET', 'compile.dwasm.txt', false);
      xmlhttp.send();
      compilerSource.innerHTML = xmlhttp.responseText;
      xmlhttp.open('GET', 'compile.dwasm.bin.txt', false);
      xmlhttp.send();
      compilerBinary.value = xmlhttp.responseText;
      xmlhttp.open('GET', 'playtest.dwasm.txt', false);
      xmlhttp.send();
      code.value = xmlhttp.responseText;

      function hexStringToByte(str) {
        if (!str) {
          return new Uint8Array();
        }
        var a = [];
        for (var i = 0, len = str.length; i < len; i += 2) {
          a.push(parseInt(str.substr(i, 2), 16));
        }
        return new Uint8Array(a);
      };

      function byteToHexString(uint8arr) {
        if (!uint8arr) {
          return '';
        }
        var hexStr = '';
        for (var i = 0; i < uint8arr.length; i++) {
          var hex = (uint8arr[i] & 0xff).toString(16);
          hex = (hex.length === 1) ? '0' + hex : hex;
          hexStr += hex + ',';
        }
        return hexStr.slice(0, -1);
      }

      function byteToDumpString(uint8arr) {
        if (!uint8arr) {
          return '';
        }
        var hexStr = '';
        for (var i = 0; i < uint8arr.length; i++) {
          var hex = (uint8arr[i] & 0xff).toString(16);
          hex = (hex.length === 1) ? '0' + hex : hex;
          hexStr += hex;
          if (i % 4 == 3) {
            hexStr += ' ';
          };
        };
        hexStr = hexStr.replace(/01dec0de/g, '\nDEBUG   ');
        hexStr = hexStr.replace(/02dec0de/g, '\nNode    ');
        hexStr = hexStr.replace(/03dec0de/g, '\nScope   ');
        hexStr = hexStr.replace(/04dec0de/g, '\nList    ');
        hexStr = hexStr.replace(/05dec0de/g, '\nItem    ');
        hexStr = hexStr.replace(/06dec0de/g, '\nToken   ');
        hexStr = hexStr.replace(/07dec0de/g, '\nString  ');
        return hexStr;
      }

      compile.onclick = (e) => {
        var bytes = compilerBinary.value.trim();
        bytes = hexStringToByte(bytes.replace(/,/g, ""));
        binary.value = "";
        compilerLog.value = "";
        WebAssembly.instantiate(bytes).then(results => {
          let main = results.instance.exports.main;
          let mem = new Uint8Array(results.instance.exports.mem.buffer);
          let sourcecode = code.value;
          new Uint32Array(mem.buffer)[2] = sourcecode.length;
          for (var i = 0, strLen = sourcecode.length; i < strLen; i++) { mem[i + 12] = sourcecode.charCodeAt(i); }
          let out = main();
          let binLen = mem[out] + 256*mem[out + 1] + 256*256*mem[out + 2] + 256*256*256*mem[out + 3];
          if (out > 0) {
            out = out + 4;
            let magic = mem[out] + 256*mem[out + 1] + 256*256*mem[out + 2] + 256*256*256*mem[out + 3];
            if (magic == 1836278016) {
              binary.value = byteToHexString(mem.slice(out, out + binLen));
            } else {
              binary.value = String.fromCharCode.apply(null, mem.slice(out, out + binLen));
            };
            if (binLen < 10000) {
              compilerLog.value = byteToDumpString(mem.slice(0, out + binLen));
            };
          };
        });
      };

      execute.onclick = (e) => {
        var bytes = binary.value;
        bytes = hexStringToByte(bytes.replace(/,/g, ""));
        execResult.value = "";
        execMemDump.value = "";
        WebAssembly.instantiate(bytes).then(results => {
          let main = results.instance.exports.main;
          let mem = new Uint8Array(results.instance.exports.mem.buffer);
          let out = main();
          execResult.value = out;
          execMemDump.value = byteToDumpString(mem.slice(0, 24000));
        });
      };
    </script>
  </body>
</html>
