<html>
  <head>
    <link href="prism.css" rel="stylesheet" />
  </head>
  <body>
    <h1>WebAssembly Compiler</h1>
    <table width="99%">
      <tr>
        <td width="60%">Compiler source code</td>
        <td>Compiler WebAssembly binary</td>
      </tr><tr>
        <td height="500px"><pre><code class="language-c">// Compile.wasmat v0.1.20170709
// A toy language with self-compiling compiler to WebAssembly
// A subset of WebAssembly is implemented - enough for self-compilation
// Most reserved words and built-in functions compile to a single WebAssembly instruction
// As a convention, pointers and functions returning pointers start with a Capital letter
// Pierre Rossouw 2017 https://github.com/PierreRossouw/Wasmat

// Most browsers only support 32bit WASM for now
i32 sizeInt := 4

// Enums
i32 nodes_program    := 1
i32 nodes_block      := 2
i32 nodes_binary     := 3
i32 nodes_unary      := 4
i32 nodes_call       := 5
i32 nodes_return     := 6
i32 nodes_if         := 7
i32 nodes_loop       := 8
i32 nodes_break      := 9
i32 nodes_continue   := 10
i32 nodes_fun        := 11
i32 nodes_variable   := 12
i32 nodes_parameter  := 13
i32 nodes_literal    := 14

i32 tokens_identifier  := 43
i32 tokens_charLiteral := 46
i32 tokens_numLiteral  := 47
i32 tokens_lParen      := 50
i32 tokens_comma       := 51
i32 tokens_rParen      := 52
i32 tokens_fun         := 60
i32 tokens_return      := 61
i32 tokens_endfun      := 62
i32 tokens_loop        := 70
i32 tokens_continue    := 71
i32 tokens_break       := 72
i32 tokens_endloop     := 73
i32 tokens_if          := 80
i32 tokens_then        := 81
i32 tokens_elseif      := 82
i32 tokens_else        := 83
i32 tokens_endif       := 84
i32 tokens_minPrec     := 99
i32 tokens_assign      := 100  // :=
i32 tokens_or          := 101
i32 tokens_and         := 102
i32 tokens_eq          := 110  // =
i32 tokens_ne          := 111  // <>
i32 tokens_lt          := 112  // <
i32 tokens_le          := 113  // <=
i32 tokens_gt          := 114  // >
i32 tokens_ge          := 115  // >=
i32 tokens_shl         := 116  // <<
i32 tokens_shr         := 117  // >>
i32 tokens_add         := 118  // +
i32 tokens_sub         := 119  // -
i32 tokens_mul         := 120  // *
i32 tokens_div         := 121  // /
i32 tokens_mod         := 122
i32 tokens_not         := 123
i32 tokens_f64         := 124  // 0x7c
i32 tokens_f32         := 125  // 0x7d 
i32 tokens_i64         := 126  // 0x7e
i32 tokens_i32         := 127  // 0x7f

// Structs
i32 string_length := 8
i32 string_Chars  := 12

i32 list_First := 8
i32 list_Last  := 12
i32 list_count := 16
i32 list_size  := 20

i32 item_Next   := 8
i32 item_Name   := 12
i32 item_Object := 16
i32 item_size   := 20

i32 token_kind   := 8
i32 token_Value  := 12
i32 token_line   := 16
i32 token_column := 20
i32 token_size   := 24

i32 node_kind       := 8   // From the nodes_ enum
i32 node_type       := 12  // From the tokens_ enum
i32 node_index      := 16  // Zero based index number for funs, variables, parameters
i32 node_String     := 20  // Literal value, or fun/var/parameter name
i32 node_Scope      := 24  // Scope for program/block/loop/fun used for name resolution
i32 node_ANode      := 28  // Binary left, call fun, return expression, then block, or fun body
i32 node_BNode      := 32  // Binary/unary right, else block, fun return, variable assignment
i32 node_CNode      := 36  // If statement condition node
i32 node_Nodes      := 40  // List of child nodes for program/block, or fun locals
i32 node_ParamNodes := 44  // List of params for call/fun
i32 node_size       := 48

i32 scope_Node       := 8
i32 scope_index      := 12
i32 scope_Parent     := 16
i32 scope_Symbols    := 20
i32 scope_localIndex := 24
i32 scope_size       := 28

// Global variables
i32 Heap             := 4  // Memory management - reserve 0-3 for null pointers
i32 TokenList        := 0
i32 funIndex         := 0  // Next function index number
i32 CurrentTokenItem := 0
i32 CurrentToken     := 0
i32 CurrentScope     := 0
i32 GlobalScope      := 0
i32 RootNode         := 0
i32 Binary           := 0
i32 BinaryPointer    := 0
i32 emitGlobalCount  := 0
i32 emitFunCount     := 0

// The first function is automatically exported as 'main'
fun i32 Compile()
  i32 length := load32(8)
  i32 ignore := Alloc(8 + length)
  lexx(0)
  parse()
  emit(length)
  return Binary + string_length
endfun

// Memory management
fun i32 Alloc(i32 length)
  i32 r := Heap
  Heap := Heap + length
  if Heap mod sizeInt then
    Heap := Heap + sizeInt - Heap mod sizeInt  // Fix the alignment
  endif
  return r
endfun

fun debug(i32 X)
  i32 D := Alloc(8)
  store32(D, 0 - 557785600)  // Magic number 0x00dec0de - for debugging
  store32(D + 4, X)
endfun

// Pascal-style strings: We store the length instead of using a null terminator
fun i32 NewString(i32 length)
  i32 String := Alloc(string_Chars + length)
  store32(String + string_length, length)
  return String
endfun

fun i32 strLen(i32 String)
  return load32(String + string_length)
endfun

fun i32 getchar(i32 String, i32 offset)
  return load8(String + string_Chars + offset)
endfun

fun setchar(i32 String, i32 offset, i32 chr)
  store8(String + string_Chars + offset, chr)
endfun

fun i32 Substring(i32 String, i32 offset, i32 length)
  if offset >= strLen(String) then
    length := 0
  endif
  if (offset + length) >= strLen(String) then
    length := strLen(String) - offset
  endif
  i32 R := NewString(length)
  loop
    if length = 0 then break endif
    length := length - 1
    setchar(R, length, getchar(String, offset + length))
  endloop
  return R
endfun

fun i32 strCompare(i32 A, i32 B)
  i32 length := strLen(A)
  i32 offset := 0
  i32 r := 1
  if length = strLen(B) then
    loop
      if getchar(A, offset) <> getchar(B, offset) then
        r := 0
        break
      endif
      if offset >= length then break endif
      offset := offset + 1
    endloop
  else
    r := 0
  endif
  return r
endfun

fun i32 strcomp32(i32 V, i32 a)
  i32 r := 1
  i32 length := strLen(V)
  if length = 0 or length > 4 then
    r := 0
  else
    if load32(V + string_Chars) <> a then r := 0 endif
  endif
  return r
endfun

fun i32 strcomp64(i32 V, i32 a, i32 b)
  i32 r := 1
  i32 length := strLen(V)
  if length < 5 or length > 8 then
    r := 0
  else
    if load32(V + string_Chars) <> a then r := 0 endif
    if load32(V + string_Chars + 4) <> b then r := 0 endif
  endif
  return r
endfun

// Lists
fun listAdd(i32 List, i32 Object)
  i32 Item := Alloc(item_size)
  store32(Item + item_Object, Object)
  if not load32(List + list_First) then
    store32(List + list_First, Item)
  else
    store32(load32(List + list_Last) + item_Next, Item) 
  endif
  store32(List + list_Last, Item) 
  store32(List + list_count, load32(List + list_count) + 1)
endfun

fun listAddName(i32 List, i32 Object, i32 Name)
  i32 Item := Alloc(item_size)
  store32(Item + item_Object, Object)
  store32(Item + item_Name, Name)
  if not load32(List + list_First) then
    store32(List + list_First, Item)
  else
    store32(load32(List + list_Last) + item_Next, Item)
  endif
  store32(List + list_Last, Item) 
  store32(List + list_count, load32(List + list_count) + 1)
endfun

// Find a string in a list
fun i32 ListSearch(i32 List, i32 FindName)
  i32 Item := load32(List + list_First)
  i32 Node := 0
  loop
    if not Item then break endif
    if strCompare(load32(Item + item_Name), FindName) then
      Node := load32(Item + item_Object)
      break
    endif
    Item := load32(Item + item_Next)
  endloop
  return Node
endfun

// Lexer XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun addToken(i32 kind, i32 Value, i32 line, i32 column)
  if not TokenList then
    TokenList := Alloc(list_size)
  endif
  i32 Token := Alloc(token_size)
  store32(Token + token_kind, kind)
  store32(Token + token_Value, Value)
  store32(Token + token_line, line)
  store32(Token + token_column, column)
  listAdd(TokenList, Token)
endfun

fun processToken(i32 Val, i32 line, i32 column)
  i32 kind := tokens_identifier
  if strcomp32(Val, '(') then kind := tokens_lParen endif
  if strcomp32(Val, ',') then kind := tokens_comma endif
  if strcomp32(Val, ')') then kind := tokens_rParen endif
  if strcomp32(Val, 'fun') then kind := tokens_fun endif
  if strcomp64(Val, 'retu', 'rn') then kind := tokens_return endif
  if strcomp64(Val, 'endf', 'un') then kind := tokens_endfun endif
  if strcomp32(Val, 'loop') then kind := tokens_loop endif
  if strcomp64(Val, 'cont', 'inue') then kind := tokens_continue endif
  if strcomp64(Val, 'brea', 'k') then kind := tokens_break endif
  if strcomp64(Val, 'endl', 'oop') then kind := tokens_endloop endif
  if strcomp32(Val, 'if') then kind := tokens_if endif
  if strcomp32(Val, 'then') then kind := tokens_then endif
  if strcomp32(Val, 'else') then kind := tokens_else endif
  if strcomp64(Val, 'else', 'if') then kind := tokens_elseif endif
  if strcomp64(Val, 'endi', 'f') then kind := tokens_endif endif
  if strcomp32(Val, 'i32') then kind := tokens_i32 endif
  if strcomp32(Val, 'i64') then kind := tokens_i64 endif
  if strcomp32(Val, 'f32') then kind := tokens_f32 endif
  if strcomp32(Val, 'f64') then kind := tokens_f64 endif
  if strcomp32(Val, ':=') then kind := tokens_assign endif
  if strcomp32(Val, 'or') then kind := tokens_or endif
  if strcomp32(Val, 'and') then kind := tokens_and endif
  if strcomp32(Val, '=') then kind := tokens_eq endif
  if strcomp32(Val, '<>') then kind := tokens_ne endif
  if strcomp32(Val, '<') then kind := tokens_lt endif
  if strcomp32(Val, '<=') then kind := tokens_le endif
  if strcomp32(Val, '>') then kind := tokens_gt endif
  if strcomp32(Val, '>=') then kind := tokens_ge endif
  if strcomp32(Val, '<<') then kind := tokens_shl endif
  if strcomp32(Val, '>>') then kind := tokens_shr endif
  if strcomp32(Val, '+') then kind := tokens_add endif
  if strcomp32(Val, '-') then kind := tokens_sub endif
  if strcomp32(Val, '*') then kind := tokens_mul endif
  if strcomp32(Val, '/') then kind := tokens_div endif
  if strcomp32(Val, 'mod') then kind := tokens_mod endif
  if strcomp32(Val, 'not') then kind := tokens_not endif
  addToken(kind, Val, line, column)
endfun

fun i32 isWhitespace(i32 chr)
  return chr = 0 or chr = 9 or chr = 13 or chr = ' '  // tab, cr, space
endfun

fun i32 isAlpha(i32 chr)
  return (chr >= 'a' and chr <= 'z') or (chr >= 'A' and chr <= 'Z') or (chr = '_')
endfun

fun i32 isNumber(i32 chr, i32 hex)
  i32 num := 0
  if chr >= '0' and chr <= '9' then
    num := 1
  elseif hex and chr >= 'a' and chr <= 'f' then
    num := 1
  endif
  return num
endfun

fun i32 isPunctuator(i32 chr)
  return chr = '(' or chr = ')' or chr = ','
endfun

fun i32 isOperatorChar(i32 chr)
  return chr = '=' or chr = '+' or chr = '-' or chr = '/' or
         chr = '<' or chr = '>' or chr = '*' or chr = ':'
endfun

fun lexx(i32 Code)
  i32 pos := 0 - 1
  i32 line := 1
  i32 col := 0
  i32 length := strLen(Code)
  i32 chr := 0
  i32 start := 0
  i32 Val := 0
  i32 hex := 0
  loop
    pos := pos + 1
    col := col + 1
    chr := getchar(Code, pos) 
    if isWhitespace(chr) then 
      continue 
    elseif chr = 10 then  // newline
      line := line + 1
      col := 0
    elseif isAlpha(chr) then
      start := pos
      loop
        if (not isAlpha(chr)) and (not isNumber(chr, 0)) then
          pos := pos - 1
          col := col - 1
          break
        endif
        pos := pos + 1
        col := col + 1
        chr := getchar(Code, pos)
      endloop
      Val := Substring(Code, start, pos - start + 1)
      processToken(Val, line, col)
    elseif chr = 39 then  // single quote '
      pos := pos + 1
      col := col + 1
      chr := getchar(Code, pos)
      start := pos
      loop
        if chr = 39 then break endif
        pos := pos + 1
        col := col + 1
        chr := getchar(Code, pos)
      endloop
      Val := Substring(Code, start, pos - start)
      addToken(tokens_charLiteral, Val, line, col)
    elseif isNumber(chr, 0) or ((chr = '-') and isNumber(getchar(Code, pos + 1), 0)) then
      start := pos
      hex := 0
      loop
        if (not isNumber(chr, hex)) and (chr <> 45) then
          if start + 1 = pos and chr = 120 then
            hex := 1
          else
            pos := pos - 1
            col := col - 1
            break
          endif
        endif
        pos := pos + 1
        col := col + 1
        chr := getchar(Code, pos)
      endloop
      Val := Substring(Code, start, pos - start + 1)
      addToken(tokens_numLiteral, Val, line, col)
    elseif (chr = '/') and (getchar(Code, pos + 1) = '/') then
      loop
        if chr = 10 or chr = 13 then  // LF or CR
          col := 0
          line := line + 1
          break
        endif
        pos := pos + 1
        col := col + 1
        chr := getchar(Code, pos)
      endloop
    elseif isPunctuator(chr) then
      Val := Substring(Code, pos, 1)
      processToken(Val, line, col)
    elseif isOperatorChar(chr) then
      if isOperatorChar(getchar(Code, pos + 1)) then
        Val := Substring(Code, pos, 2)
        pos := pos + 1
        col := col + 1
      else
        Val := Substring(Code, pos, 1)
      endif
      processToken(Val, line, col)
    endif
    if pos >= length then break endif
  endloop
endfun

// Scoper XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun pushScope(i32 Node)
  i32 Scope := Alloc(scope_size)
  store32(Scope + scope_Symbols, Alloc(list_size))
  store32(Scope + scope_Node, Node)
  if CurrentScope then
    store32(Scope + scope_index, load32(CurrentScope + scope_index) + 1)
    store32(Scope + scope_Parent, CurrentScope)
  endif
  store32(Node + node_Scope, Scope)
  CurrentScope := Scope
endfun

fun popScope()
  if CurrentScope then
    CurrentScope := load32(CurrentScope + scope_Parent)
  endif
endfun

fun i32 LookupFunctionScope(i32 Scope)
  i32 FunScope := Scope
  loop
    if not FunScope then break endif
    if load32(load32(FunScope + scope_Node) + node_kind) then break endif
    FunScope := load32(FunScope + scope_Parent)
  endloop
  return FunScope
endfun

fun scopeRegister(i32 Scope, i32 Name, i32 Node)
  i32 nodeKind := load32(Node + node_kind)
  i32 FunScope := 0
  i32 nextIndex := 0
  listAddName(load32(Scope + scope_Symbols), Node, Name)
  if nodeKind = nodes_variable or nodeKind = nodes_parameter then
    FunScope := LookupFunctionScope(Scope)
    nextIndex := load32(FunScope + scope_localIndex)
    store32(Node + node_Scope, FunScope)
    store32(Node + node_index, nextIndex)
    store32(FunScope + scope_localIndex, nextIndex + 1)
  endif
endfun

fun i32 ScopeResolve(i32 Scope, i32 Name)
  i32 Node := 0
  i32 RecurseScope := Scope
  loop
    if not RecurseScope then break endif
    Node := ListSearch(load32(RecurseScope + scope_Symbols), Name)
    if Node then break endif
    RecurseScope := load32(RecurseScope + scope_Parent)
  endloop
  return Node
endfun

// Parser XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun i32 NewNode()
  i32 Node := Alloc(node_size)
  store32(Node + node_Scope, CurrentScope)
  return Node
endfun

fun next()
  CurrentTokenItem := load32(CurrentTokenItem + item_Next)
  if CurrentTokenItem then
    CurrentToken := load32(CurrentTokenItem + item_Object)
  else
    CurrentToken := 0
  endif
endfun

fun i32 isBinaryOperator(i32 Token)
  i32 kind := load32(Token + token_kind)
  return kind = tokens_assign or kind = tokens_add or kind = tokens_sub or kind = tokens_mul or
         kind = tokens_div or kind = tokens_mod or kind = tokens_or or kind = tokens_and or
         kind = tokens_lt or kind = tokens_eq or kind = tokens_ne or kind = tokens_lt or
         kind = tokens_le or kind = tokens_gt or kind = tokens_ge or kind = tokens_shl or
         kind = tokens_shr
endfun

fun i32 isUnaryOperator(i32 Token)
  i32 kind := load32(Token + token_kind)
  return kind = tokens_sub or kind = tokens_not
endfun

fun i32 isLiteral(i32 Token)
  i32 kind := load32(Token + token_kind)
  return kind = tokens_numLiteral or kind = tokens_identifier or kind = tokens_charLiteral
endfun

fun i32 isNativeType(i32 Token)
  i32 kind := load32(Token + token_kind)
  return kind = tokens_i32 or kind = tokens_i64 or kind = tokens_f32 or kind = tokens_f64
endfun

fun eatToken(i32 kind)
  if load32(CurrentToken + token_kind) = kind then
    next()
  else
    debug(0x99)
    debug(kind)
    debug(load32(CurrentToken + token_kind))
    debug(CurrentToken)
  endif
endfun

fun i32 ParseFunParams()
  i32 Params := Alloc(list_size)
  i32 type := 0
  i32 FunParamNode := 0
  i32 Name := 0
  eatToken(tokens_lParen)
  loop
    type := load32(CurrentToken + token_kind)
    if type = tokens_rParen then break endif
    next()
    FunParamNode := NewNode()
    store32(FunParamNode + node_kind, nodes_parameter)
    store32(FunParamNode + node_type, type)
    Name := load32(CurrentToken + token_Value)
    store32(FunParamNode + node_String, Name)
    listAddName(Params, FunParamNode, Name)
    next()
    if load32(CurrentToken + token_kind) <> tokens_comma then break endif
    next()
  endloop
  eatToken(tokens_rParen)
  return Params
endfun

fun i32 ParseFunBlock()
  i32 Node := NewNode()
  i32 BodyList := Alloc(list_size)
  i32 ChildNode := 0
  store32(Node + node_kind, nodes_block)
  store32(Node + node_Nodes, BodyList)
  store32(Node + node_Scope, CurrentScope)
  loop
    if not CurrentToken then break endif
    if load32(CurrentToken + token_kind) = tokens_endfun then break endif
    ChildNode := ParseStatement()
    if not ChildNode then break endif
    listAdd(BodyList, ChildNode)
  endloop
  return Node
endfun

fun i32 ParseFunDeclaration(i32 type, i32 Name)
  i32 Node := NewNode()
  i32 Locals := Alloc(list_size)
  i32 ParamList := 0
  i32 ParamName := 0
  i32 ParamItem := 0
  store32(Node + node_kind, nodes_fun)
  store32(Node + node_index, funIndex)
  funIndex := funIndex + 1
  store32(Node + node_type, type)
  store32(Node + node_String, Name)
  store32(Node + node_Nodes, Locals)
  scopeRegister(CurrentScope, Name, Node)
  ParamList := ParseFunParams()
  store32(Node + node_ParamNodes, ParamList)
  pushScope(Node)
  ParamItem := load32(ParamList + list_First)
  loop
    if not ParamItem then break endif
    ParamName := load32(ParamItem + item_Name)
    scopeRegister(CurrentScope, ParamName, load32(ParamItem + item_Object))
    ParamItem := load32(ParamItem + item_Next)
  endloop
  store32(Node + node_ANode, ParseFunBlock())
  popScope()
  eatToken(tokens_endfun)
  return Node
endfun

fun i32 ParseFun()
  i32 funType := 0
  i32 Name := 0
  if isNativeType(CurrentToken) then
    funType := load32(CurrentToken + token_kind)
    next()
  endif
  Name := load32(CurrentToken + token_Value)
  next()
  return ParseFunDeclaration(funType, Name)
endfun

fun i32 ParseBreak()
  i32 Node := NewNode()
  store32(Node + node_kind, nodes_break)
  eatToken(tokens_break)
  return Node
endfun

fun i32 ParseContinue()
  i32 Node := NewNode()
  store32(Node + node_kind, nodes_continue)
  eatToken(tokens_continue)
  return Node
endfun

fun i32 ParseLiteral()
  i32 Node := NewNode()
  store32(Node + node_kind, nodes_literal)
  store32(Node + node_String, load32(CurrentToken + token_Value))
  store32(Node + node_type, load32(CurrentToken + token_kind))
  next()
  return Node
endfun

fun i32 ParseCallParams()
  i32 ParamList := Alloc(list_size)
  eatToken(tokens_lParen)
  loop
    if load32(CurrentToken + token_kind) = tokens_rParen then break endif
    listAdd(ParamList, ParseExpression(tokens_minPrec))
    if load32(CurrentToken + token_kind) <> tokens_comma then break endif
    eatToken(tokens_comma)
  endloop
  eatToken(tokens_rParen)
  return ParamList
endfun

fun i32 ParseCallExpression(i32 Callee)
  i32 Node := NewNode()
  store32(Node + node_kind, nodes_call)
  store32(Node + node_ANode, Callee)
  store32(Node + node_ParamNodes, ParseCallParams())
  return Node
endfun

fun i32 parseUnaryExpression()
  i32 Node := NewNode()
  store32(Node + node_kind, nodes_unary)
  store32(Node + node_type, load32(CurrentToken + token_kind))
  store32(Node + node_String, load32(CurrentToken + token_Value))
  next()
  store32(Node + node_BNode, ParseExpression(tokens_add))
  return Node
endfun

fun i32 ParsePrefix()
  i32 Node := 0
  if isLiteral(CurrentToken) then
    Node := ParseLiteral()
  elseif load32(CurrentToken + token_kind) = tokens_lParen then
    next()
    Node := ParseExpression(tokens_minPrec)
    eatToken(tokens_rParen)
  elseif isUnaryOperator(CurrentToken) then
    Node := parseUnaryExpression()
  endif
  return Node
endfun

fun i32 ParseBinaryExpression(i32 level, i32 Left)
  i32 Node := 0
  i32 precedence := load32(CurrentToken + token_kind)  // node_kind doubles as the precedence
  if level > precedence then
    Node := Left
  else
    Node := NewNode()
    store32(Node + node_kind, nodes_binary)
    store32(Node + node_type, load32(CurrentToken + token_kind))
    store32(Node + node_String, load32(CurrentToken + token_Value))
    store32(Node + node_ANode, Left)
    next()
    store32(Node + node_BNode, ParseExpression(precedence))
  endif
  return Node
endfun

fun i32 ParseInfix(i32 level, i32 Left)
  i32 Node := 0
  if isBinaryOperator(CurrentToken) then
    Node := ParseBinaryExpression(level, Left)
  elseif load32(CurrentToken + token_kind) = tokens_lParen then
    Node := ParseCallExpression(Left)
  else
    Node := Left
  endif
  return Node
endfun

fun i32 ParseExpression(i32 level)
  i32 Node := 0
  i32 Expr := 0
  i32 kind := load32(CurrentToken + token_kind)
  if kind = tokens_break then
    Node := ParseBreak()
  elseif kind = tokens_continue then
    Node := ParseContinue()
  else
    Node := ParsePrefix()
    loop
      if not CurrentToken then break endif
      Expr := ParseInfix(level, Node)
      if Expr = 0 or Expr = Node then break endif
      Node := Expr
    endloop
  endif
  return Node
endfun

fun i32 ParseReturnStatement()
  i32 Node := NewNode()
  i32 Scope := 0
  eatToken(tokens_return)
  store32(Node + node_kind, nodes_return)
  store32(Node + node_ANode, ParseExpression(tokens_minPrec))
  Scope := CurrentScope
  loop
    if not Scope then break endif
    if load32(load32(Scope + scope_Node) + node_kind) = nodes_fun then break endif
    Scope := load32(Scope + scope_Parent)
  endloop
  store32(load32(Scope + scope_Node) + node_ANode, Node)
  return Node
endfun

fun i32 ParseIfBlock()
  i32 Node := NewNode()
  i32 BodyList := Alloc(list_size)
  i32 ChildNode := 0
  store32(Node + node_kind, nodes_block)
  store32(Node + node_Nodes, BodyList)
  store32(Node + node_Scope, CurrentScope)
  loop
    if not CurrentToken then break endif
    if load32(CurrentToken + token_kind) = tokens_else then break endif
    if load32(CurrentToken + token_kind) = tokens_elseif then break endif
    if load32(CurrentToken + token_kind) = tokens_endif then break endif
    ChildNode := ParseStatement()
    if not ChildNode then break endif
    listAdd(BodyList, ChildNode)
  endloop
  return Node
endfun

fun i32 ParseIfStatement(i32 isElseif)
  i32 Node := NewNode()
  if not isElseif then eatToken(tokens_if) endif
  store32(Node + node_kind, nodes_if)
  store32(Node + node_CNode, ParseExpression(tokens_minPrec))
  eatToken(tokens_then)
  pushScope(Node)
  store32(Node + node_ANode, ParseIfBlock())
  popScope()
  if load32(CurrentToken + token_kind) = tokens_elseif then
    eatToken(tokens_elseif)
    pushScope(Node)
    store32(Node + node_BNode, ParseIfStatement(1))
    popScope()
  endif
  if load32(CurrentToken + token_kind) = tokens_else then
    eatToken(tokens_else)
    pushScope(Node)
    store32(Node + node_BNode, ParseIfBlock())
    popScope()
  endif
  if not isElseif then eatToken(tokens_endif) endif
  return Node
endfun

fun i32 ParseLoopBlock()
  i32 Node := NewNode()
  i32 BodyList := Alloc(list_size)
  i32 ChildNode := 0
  store32(Node + node_kind, nodes_block)
  store32(Node + node_Nodes, BodyList)
  store32(Node + node_Scope, CurrentScope)
  loop
    if not CurrentToken then break endif
    if load32(CurrentToken + token_kind) = tokens_endloop then break endif
    ChildNode := ParseStatement()
    if not ChildNode then break endif
    listAdd(BodyList, ChildNode)
  endloop
  return Node
endfun

fun i32 ParseLoopStatement()
  i32 Node := NewNode()
  eatToken(tokens_loop)
  store32(Node + node_kind, nodes_loop)
  pushScope(Node)
  store32(Node + node_ANode, ParseLoopBlock())
  popScope()
  eatToken(tokens_endloop)
  return Node
endfun

fun i32 ParseDeclaration()
  i32 FunNode := 0
  i32 FunLocalsList := 0
  i32 type := load32(CurrentToken + token_kind)
  next()
  i32 Name := load32(CurrentToken + token_Value)
  next()
  i32 Node := NewNode()
  store32(Node + node_kind, nodes_variable)
  store32(Node + node_type, type)
  store32(Node + node_String, Name)
  scopeRegister(CurrentScope, Name, Node)
  eatToken(tokens_assign)
  store32(Node + node_BNode, ParseExpression(tokens_minPrec))
  if load32(CurrentScope + scope_Parent) then
    FunNode := load32(LookupFunctionScope(CurrentScope) + scope_Node)
    FunLocalsList := load32(FunNode + node_Nodes)
    if not FunLocalsList then
      FunLocalsList := Alloc(list_size)
      store32(FunNode + node_Nodes, FunLocalsList)
    endif
    listAdd(FunLocalsList, Node)
  endif
  return Node
endfun

fun i32 ParseStatement()
  i32 Node := 0
  i32 kind := load32(CurrentToken + token_kind)
  if kind = tokens_fun then
    eatToken(tokens_fun)
    Node := ParseFun()
  elseif isNativeType(CurrentToken) then
    Node := ParseDeclaration()
  elseif kind = tokens_return then
    Node := ParseReturnStatement()
  elseif kind = tokens_if then
    Node := ParseIfStatement(0)
  elseif kind = tokens_loop then
    Node := ParseLoopStatement()
  else
    Node := ParseExpression(tokens_minPrec)
  endif
  return Node
endfun

fun parse()
  RootNode := NewNode()
  CurrentTokenItem := load32(TokenList + list_First)
  CurrentToken := load32(CurrentTokenItem + item_Object)
  store32(RootNode + node_kind, nodes_program)
  pushScope(RootNode)
  GlobalScope := CurrentScope  
  i32 Child := 0
  i32 BodyList := Alloc(list_size)
  store32(RootNode + node_Nodes, BodyList)
  loop
    if not CurrentToken then break endif
    Child := ParseStatement()
    if not Child then break endif
    listAdd(BodyList, Child)
  endloop
endfun

// Compiler XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

fun i32 strToI32(i32 V)  // Supports ints and lowercase 0x hex
  i32 hex := 0
  i32 i := 0
  i32 length := strLen(V)
  i32 offset := 0
  i32 c := 0
  if length >= 3 then
    if getchar(V, 0) = '0' and getchar(V, 1) = 'x' then
      hex := 1
    endif
  endif
  if hex then
    offset := 2
    loop
      if offset >= length then break endif
      i := i * 16
      c := getchar(V, offset)
      if c >= '0' and c <= '9' then  // 0-9
        i := i + c - '0'
      elseif c >= 'a' and c <= 'f' then  // a-f
        i := i + c - 'a' + 10
      endif
      offset := offset + 1
    endloop
  else
    loop
      if offset >= length then break endif
      i := i * 10
      c := getchar(V, offset)
      if c >= '0' and c <= '9' then  // 0-9
        i := i + c - '0'
      endif
      offset := offset + 1
    endloop
  endif
  if getchar(V, 0) = '-' then i := 0 - i endif
  return i
endfun

fun emitByte(i32 byte)
  store8(BinaryPointer, byte)
  BinaryPointer := BinaryPointer + 1
endfun

fun emitI32(i32 byte)
  store32(BinaryPointer, byte)
  BinaryPointer := BinaryPointer + 4
endfun

fun i32 uLebLen(i32 i)
  i32 length := 0
  if i <= 127 then
    length := 1
  elseif i <= 16383 then
    length := 2
  elseif i <= 2097151 then
    length := 3
  elseif i <= 268435455 then
    length := 4
  else
    length := 5
  endif
  return length
endfun

fun emitUleb(i32 i)  // en.wikipedia.org/wiki/LEB128
  loop
    if i < 128 then break endif
    emitByte(128 + (i mod 128))
    i := i / 128  
  endloop
  emitByte(i)
endfun

fun emitSleb(i32 i)
  if i >= 0 then 
    loop
      if i < 64 then break endif
      emitByte(128 + (i mod 128))
      i := i / 128
    endloop
    emitByte(i)
  else
    loop
      if i >= (0 - 64) then break endif
      emitByte((i mod 128) - 128)
      i := i / 128
    endloop
    emitByte(i - 128)
  endif
endfun

fun fixUlebGuess(i32 Start, i32 offset)
  i32 Copy := BinaryPointer
  if offset > 0 then
    loop
      Copy := Copy - 1
      if Copy < Start then break endif
      store8(Copy + offset, load8(Copy))
    endloop
  endif
endfun

fun emitType(i32 Node)
  i32 ParamList := load32(Node + node_ParamNodes)
  emitByte(0x60)  // fun type
  emitUleb(load32(ParamList + list_count)) 
  i32 ParamItem := load32(ParamList + list_First)
  loop
    if not ParamItem then break endif
    emitByte(load32(load32(ParamItem + item_Object) + node_type))
    ParamItem := load32(ParamItem + item_Next)
  endloop
  i32 returnType := load32(Node + node_type)
  if returnType then
    emitByte(0x01)  // return count
    emitByte(returnType)
  else
    emitByte(0x00)  // return count
  endif
endfun

fun emitTypeSection()
  i32 Start := 0
  i32 count := 0
  i32 Item := 0
  i32 Node := 0
  i32 length := 0
  i32 offset := 0
  i32 BodyList := load32(RootNode + node_Nodes)
  i32 Skip := BinaryPointer
  if BodyList then
    if load32(BodyList + list_count) then
      emitByte(0x01)  // Type section
      emitByte(0x00)  // section size (guess)
      Start := BinaryPointer 
      emitByte(0x00)  // types count (guess)  
      count := 0
      Item := load32(BodyList + list_First)
      loop
        Node := load32(Item + item_Object)
        if load32(Node + node_kind) = nodes_fun then
          emitType(Node)
          count := count + 1
          emitFunCount := emitFunCount + 1
        endif
        Item := load32(Item + item_Next)
        if not Item then break endif
      endloop
      length := BinaryPointer - Start
      offset := uLebLen(count) + uLebLen(length) - 2
      fixUlebGuess(Start, offset)
      BinaryPointer := Start - 1
      emitUleb(length)
      emitUleb(count)
      BinaryPointer := BinaryPointer + length - 1
    endif
  endif
  if not emitFunCount then BinaryPointer := Skip endif
endfun

fun emitFunctionSection()
  i32 Start := 0
  i32 counter := 0
  i32 length := 0
  i32 offset := 0
  if emitFunCount then
    emitByte(0x03)  // Function section
    emitByte(0x00)  // section size (guess)
    Start := BinaryPointer 
    emitUleb(emitFunCount)  // types count
    loop
      if counter >= emitFunCount then break endif
      emitUleb(counter)
      counter := counter + 1
    endloop
    length := BinaryPointer - Start
    offset := uLebLen(length) - 1
    fixUlebGuess(Start, offset)
    BinaryPointer := Start - 1
    emitUleb(length)
    BinaryPointer := BinaryPointer + length
  endif
endfun

// Memory is exported as 'mem' and is a fixed size
// This compiler takes about 1MB to compile
fun emitMemorySection()
  emitByte(0x05)  // Memory section
  emitUleb(0x03)  // Size in bytes
  emitByte(0x01)  // Sount. A maximum of 1 currently in WebAssembly
  emitByte(0x00)  // Resizable flag
  emitByte(0x70)  // Pages (A page is 64kb)
endfun

fun emitGlobalSection()
  i32 Start := 0
  i32 count := 0
  i32 Item := 0
  i32 Node := 0
  i32 Value := 0
  i32 length := 0
  i32 offset := 0
  i32 BodyList := load32(RootNode + node_Nodes)
  i32 Skip := BinaryPointer
  if BodyList then
    if load32(BodyList + list_count) then
      emitByte(0x06)  // Section code
      emitByte(0x00)  // Section size (guess)
      Start := BinaryPointer 
      emitByte(0x00)  // Globals count (guess)
      Item := load32(BodyList + list_First)
      loop
        Node := load32(Item + item_Object)
        if load32(Node + node_kind) = nodes_variable then
          emitByte(load32(Node + node_type))  // Native type
          emitByte(0x01)  // Mutable
          emitByte(0x41)  // i32.const
          Value := load32(load32(Node + node_BNode) + node_String)
          emitSleb(strToI32(Value))
          emitByte(0x0b)  // end
          count := count + 1
          emitGlobalCount := emitGlobalCount + 1
        endif
        Item := load32(Item + item_Next)
        if not Item then break endif
      endloop
      length := BinaryPointer - Start
      offset := uLebLen(count) + uLebLen(length) - 2
      fixUlebGuess(Start, offset)
      BinaryPointer := Start - 1
      emitUleb(length)
      emitUleb(count)
      BinaryPointer := BinaryPointer + length - 1
    endif
  endif
  if not emitGlobalCount then BinaryPointer := Skip endif
endfun

fun emitExportSection()
  i32 funCount := 0
  i32 Start := 0
  i32 length := 0
  i32 offset := 0
  i32 BodyList := load32(RootNode + node_Nodes)
  if BodyList then
    funCount := load32(BodyList + list_count)
    if funCount then
      emitByte(0x07)  // Export section
      emitByte(0x00)  // Section size (guess)
      Start := BinaryPointer 
      emitByte(0x02)  // Export count
      emitByte(0x04)  // 1: Name length
      emitByte(0x6d)  // m
      emitByte(0x61)  // a
      emitByte(0x69)  // i
      emitByte(0x6e)  // n
      emitByte(0x00)  // Type: function
      emitUleb(0x00)  // Function number 0
      emitByte(0x03)  // 2: Name length
      emitByte(0x6d)  // m
      emitByte(0x65)  // e
      emitByte(0x6d)  // m
      emitByte(0x02)  // Type: memory
      emitByte(0x00)  // Memory number 0 
      length := BinaryPointer - Start
      offset := uLebLen(length) - 1
      fixUlebGuess(Start, offset)
      BinaryPointer := Start - 1
      emitUleb(length)
      BinaryPointer := BinaryPointer + length
    endif
  endif
endfun

fun emitAssignment(i32 Node)
  i32 ResolvedNode := ScopeResolve(CurrentScope, load32(load32(Node + node_ANode) + node_String))
  emitNode(load32(Node + node_BNode))
  if load32(ResolvedNode + node_Scope) = GlobalScope then
    emitByte(0x24)  // i32.set_global
  else
    emitByte(0x21)  // i32.set_local
  endif
  emitUleb(load32(ResolvedNode + node_index))
endfun

fun emitOperator(i32 type)
  if type = tokens_eq then emitByte(0x46) endif
  if type = tokens_ne then emitByte(0x47) endif
  if type = tokens_lt then emitByte(0x48) endif
  if type = tokens_le then emitByte(0x4c) endif
  if type = tokens_gt then emitByte(0x4a) endif
  if type = tokens_ge then emitByte(0x4e) endif
  if type = tokens_add then emitByte(0x6a) endif
  if type = tokens_sub then emitByte(0x6b) endif
  if type = tokens_mul then emitByte(0x6c) endif
  if type = tokens_div then emitByte(0x6d) endif
  if type = tokens_mod then emitByte(0x6f) endif
  if type = tokens_and then emitByte(0x71) endif
  if type = tokens_or then emitByte(0x72) endif
  if type = tokens_not then emitByte(0x45) endif
  if type = tokens_shl then emitByte(0x74) endif
  if type = tokens_shr then emitByte(0x75) endif
endfun

fun emitUnary(i32 Node)
  i32 type := load32(Node + node_type)
  if type = tokens_sub then
    emitByte(0x41)  // i32.const 
    emitByte(0x00)  // 0
  endif
  emitNode(load32(Node + node_BNode))
  emitOperator(type)
endfun

fun emitLiteral(i32 Node)
  i32 type := load32(Node + node_type) 
  i32 num := 0
  i32 ResolvedNode := 0
  if type = tokens_numLiteral then
    emitByte(0x41)  // i32.const
    num := strToI32(load32(Node + node_String))
    emitSleb(num)
  else
    if type = tokens_identifier then
      ResolvedNode := ScopeResolve(CurrentScope, load32(Node + node_String))
      if load32(ResolvedNode + node_Scope) = GlobalScope then
        emitByte(0x23)  // i32.get_global
      else
        emitByte(0x20)  // i32.get_local
      endif
      emitUleb(load32(ResolvedNode + node_index))
    else
      if type = tokens_charLiteral then
        emitByte(0x41)  // i32.const
        num := load32(load32(Node + node_String) + string_Chars)
        emitSleb(num)
      endif
    endif
  endif
endfun

fun emitCall(i32 Node)
  i32 ParamList := load32(Node + node_ParamNodes)
  i32 ParamItem := load32(ParamList + list_First)
  i32 ResolvedNode := 0
  loop
    if not ParamItem then break endif
    emitNode(load32(ParamItem + item_Object))
    ParamItem := load32(ParamItem + item_Next)
  endloop
  i32 Name := load32(load32(Node + node_ANode) + node_String)
  if strcomp64(Name, 'stor', 'e32') then
    emitByte(0x36)  // i32.store32
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strcomp64(Name, 'stor', 'e8') then
    emitByte(0x3a)  // i32.store8
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strcomp64(Name, 'load', '32') then
    emitByte(0x28)  // i32.load32
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  elseif strcomp64(Name, 'load', '8') then
    emitByte(0x2d)  // i32.load8
    emitByte(0x00)  // alignment
    emitByte(0x00)  // offset
  else
    ResolvedNode := ScopeResolve(CurrentScope, Name)
    emitByte(0x10)  // call
    emitUleb(load32(ResolvedNode + node_index))
  endif
endfun

fun emitBlock(i32 Node)
  i32 kind := load32(Node + node_kind)
  i32 type := load32(Node + node_type)
  i32 Scope := load32(Node + node_Scope)
  if Scope then
    CurrentScope := Scope
  endif
  i32 BlockList := load32(Node + node_Nodes)
  i32 Item := load32(BlockList + list_First)
  loop
    if not Item then break endif
    emitNode(load32(Item + item_Object))
    Item := load32(Item + item_Next)
  endloop
  if Scope then
    CurrentScope := load32(CurrentScope + scope_Parent)
  endif
endfun

fun emitIf(i32 Node)
  emitNode(load32(Node + node_CNode))  // If condition expression
  emitByte(0x04)  // if
  emitByte(0x40)  // void
  emitNode(load32(Node + node_ANode))  // Then block
  i32 ElseBlock := load32(Node + node_BNode)
  if ElseBlock then
    emitByte(0x05)  // else
    emitNode(ElseBlock)
  endif
  emitByte(0x0b)  // end
endfun

fun i32 loopLevel() 
  i32 Scope := CurrentScope
  i32 level := 0
  loop
    if not Scope then break endif
    if load32(load32(Scope + scope_Node) + node_kind) = nodes_loop then break endif
    level := level + 1
    Scope := load32(Scope + scope_Parent)
  endloop
  return level
endfun

fun emitLoop(i32 Node)
  emitByte(0x02)  // block
  emitByte(0x40)  // void 
  emitByte(0x03)  // loop
  emitByte(0x40)  // void 
  emitNode(load32(Node + node_ANode))
  emitByte(0x0c)  // br
  emitByte(0x00)  // level 
  emitByte(0x0b)  // end
  emitByte(0x0b)  // end
endfun

fun emitNode(i32 Node)
  i32 kind := load32(Node + node_kind)
  i32 type := load32(Node + node_type)
  if kind = nodes_block then
    emitBlock(Node)
  elseif kind = nodes_binary then
    if type = tokens_assign then
      emitAssignment(Node)
    else
      emitNode(load32(Node + node_ANode))
      emitNode(load32(Node + node_BNode))
      emitOperator(type)
    endif
  elseif kind = nodes_unary then
    emitUnary(Node)
  elseif kind = nodes_call then
    emitCall(Node)
  elseif kind = nodes_return then
    emitNode(load32(Node + node_ANode))
  elseif kind = nodes_if then
    emitIf(Node)
  elseif kind = nodes_loop then
    emitLoop(Node)
  elseif kind = nodes_break then
    emitByte(0x0c)  // br
    emitUleb(loopLevel() + 1)
  elseif kind = nodes_continue then
    emitByte(0x0c)  // br
    emitUleb(loopLevel())
  elseif kind = nodes_literal then
    emitLiteral(Node)
  elseif kind = nodes_variable then
    emitNode(load32(Node + node_BNode))
    emitByte(0x21)  // i32.set_local
    emitUleb(load32(Node + node_index))
  endif
endfun

fun emitFunCode(i32 Node)
  emitByte(0x00)  // Function size (guess)
  i32 Start := BinaryPointer
  i32 LocalList := load32(Node + node_Nodes)
  emitUleb(load32(LocalList + list_count))
  i32 LocalItem := load32(LocalList + list_First)
  loop
    if not LocalItem then break endif
    emitByte(0x01)  // count
    emitByte(load32(load32(LocalItem + item_Object) + node_type))
    LocalItem := load32(LocalItem + item_Next)
  endloop
  emitNode(load32(Node + node_ANode))  // Body block node
  emitByte(0x0b)  // end
  i32 length := BinaryPointer - Start
  i32 offset := uLebLen(length) - 1
  fixUlebGuess(Start, offset)
  BinaryPointer := Start - 1
  emitUleb(length)
  BinaryPointer := BinaryPointer + length
endfun

fun emitCodeSection()
  i32 Start := 0
  i32 BodyList := 0
  i32 FunItem := 0
  i32 FunNode := 0
  i32 length := 0
  i32 offset := 0
  if emitFunCount then
    emitByte(0x0a)  // Code section
    emitByte(0x00)  // Section size (guess)
    Start := BinaryPointer 
    emitUleb(emitFunCount)
    BodyList := load32(RootNode + node_Nodes)
    FunItem := load32(BodyList + list_First)
    loop
      FunNode := load32(FunItem + item_Object)
      if load32(FunNode + node_kind) = nodes_fun then
        emitFunCode(FunNode)
      endif
      FunItem := load32(FunItem + item_Next)
      if not FunItem then break endif
    endloop
    length := BinaryPointer - Start
    offset := uLebLen(length) - 1
    fixUlebGuess(Start, offset)
    BinaryPointer := Start - 1
    emitUleb(length)
    BinaryPointer := BinaryPointer + length
  endif
endfun

fun emit(i32 length)
  Binary := NewString(length + 256)  // Heuristic: binary will be smaller than length(source) + 256
  BinaryPointer := Binary + string_Chars
  CurrentScope := load32(RootNode + node_Scope)
  emitByte(0x00)  // Wasm magic: 00 61 73 6d
  emitByte(0x61)  // a
  emitByte(0x73)  // s
  emitByte(0x6d)  // m
  emitI32(1)      // Wasm version
  emitTypeSection()
  emitFunctionSection()
  emitMemorySection()
  emitGlobalSection()
  emitExportSection()
  emitCodeSection()
  store32(Binary + string_length, BinaryPointer - (Binary + string_Chars))  // Fix up the length
endfun
</code></pre></td>
        <td><textarea id="compilerBinary">00,61,73,6d,01,00,00,00,01,f6,02,52,60,00,01,7f,60,01,7f,01,7f,60,01,7f,00,60,01,7f,01,7f,60,01,7f,01,7f,60,02,7f,7f,01,7f,60,03,7f,7f,7f,00,60,03,7f,7f,7f,01,7f,60,02,7f,7f,01,7f,60,02,7f,7f,01,7f,60,03,7f,7f,7f,01,7f,60,02,7f,7f,00,60,03,7f,7f,7f,00,60,02,7f,7f,01,7f,60,04,7f,7f,7f,7f,00,60,03,7f,7f,7f,00,60,01,7f,01,7f,60,01,7f,01,7f,60,02,7f,7f,01,7f,60,01,7f,01,7f,60,01,7f,01,7f,60,01,7f,00,60,01,7f,00,60,00,00,60,01,7f,01,7f,60,03,7f,7f,7f,00,60,02,7f,7f,01,7f,60,00,01,7f,60,00,00,60,01,7f,01,7f,60,01,7f,01,7f,60,01,7f,01,7f,60,01,7f,01,7f,60,01,7f,00,60,00,01,7f,60,00,01,7f,60,02,7f,7f,01,7f,60,00,01,7f,60,00,01,7f,60,00,01,7f,60,00,01,7f,60,00,01,7f,60,01,7f,01,7f,60,00,01,7f,60,00,01,7f,60,02,7f,7f,01,7f,60,02,7f,7f,01,7f,60,01,7f,01,7f,60,00,01,7f,60,00,01,7f,60,01,7f,01,7f,60,00,01,7f,60,00,01,7f,60,00,01,7f,60,00,01,7f,60,00,00,60,01,7f,01,7f,60,01,7f,00,60,01,7f,00,60,01,7f,01,7f,60,01,7f,00,60,01,7f,00,60,02,7f,7f,00,60,01,7f,00,60,00,00,60,00,00,60,00,00,60,00,00,60,00,00,60,01,7f,00,60,01,7f,00,60,01,7f,00,60,01,7f,00,60,01,7f,00,60,01,7f,00,60,01,7f,00,60,00,01,7f,60,01,7f,00,60,01,7f,00,60,01,7f,00,60,00,00,60,01,7f,00,03,53,52,00,01,02,03,04,05,06,07,08,09,0a,0b,0c,0d,0e,0f,10,11,12,13,14,15,16,17,18,19,1a,1b,1c,1d,1e,1f,20,21,22,23,24,25,26,27,28,29,2a,2b,2c,2d,2e,2f,30,31,32,33,34,35,36,37,38,39,3a,3b,3c,3d,3e,3f,40,41,42,43,44,45,46,47,48,49,4a,4b,4c,4d,4e,4f,50,51,05,03,01,00,70,06,8f,04,63,7f,01,41,04,0b,7f,01,41,01,0b,7f,01,41,02,0b,7f,01,41,03,0b,7f,01,41,04,0b,7f,01,41,05,0b,7f,01,41,06,0b,7f,01,41,07,0b,7f,01,41,08,0b,7f,01,41,09,0b,7f,01,41,0a,0b,7f,01,41,0b,0b,7f,01,41,0c,0b,7f,01,41,0d,0b,7f,01,41,0e,0b,7f,01,41,2b,0b,7f,01,41,2e,0b,7f,01,41,2f,0b,7f,01,41,32,0b,7f,01,41,33,0b,7f,01,41,34,0b,7f,01,41,3c,0b,7f,01,41,3d,0b,7f,01,41,3e,0b,7f,01,41,c6,00,0b,7f,01,41,c7,00,0b,7f,01,41,c8,00,0b,7f,01,41,c9,00,0b,7f,01,41,d0,00,0b,7f,01,41,d1,00,0b,7f,01,41,d2,00,0b,7f,01,41,d3,00,0b,7f,01,41,d4,00,0b,7f,01,41,e3,00,0b,7f,01,41,e4,00,0b,7f,01,41,e5,00,0b,7f,01,41,e6,00,0b,7f,01,41,ee,00,0b,7f,01,41,ef,00,0b,7f,01,41,f0,00,0b,7f,01,41,f1,00,0b,7f,01,41,f2,00,0b,7f,01,41,f3,00,0b,7f,01,41,f4,00,0b,7f,01,41,f5,00,0b,7f,01,41,f6,00,0b,7f,01,41,f7,00,0b,7f,01,41,f8,00,0b,7f,01,41,f9,00,0b,7f,01,41,fa,00,0b,7f,01,41,fb,00,0b,7f,01,41,fc,00,0b,7f,01,41,fd,00,0b,7f,01,41,fe,00,0b,7f,01,41,ff,00,0b,7f,01,41,08,0b,7f,01,41,0c,0b,7f,01,41,08,0b,7f,01,41,0c,0b,7f,01,41,10,0b,7f,01,41,14,0b,7f,01,41,08,0b,7f,01,41,0c,0b,7f,01,41,10,0b,7f,01,41,14,0b,7f,01,41,08,0b,7f,01,41,0c,0b,7f,01,41,10,0b,7f,01,41,14,0b,7f,01,41,18,0b,7f,01,41,08,0b,7f,01,41,0c,0b,7f,01,41,10,0b,7f,01,41,14,0b,7f,01,41,18,0b,7f,01,41,1c,0b,7f,01,41,20,0b,7f,01,41,24,0b,7f,01,41,28,0b,7f,01,41,2c,0b,7f,01,41,30,0b,7f,01,41,08,0b,7f,01,41,0c,0b,7f,01,41,10,0b,7f,01,41,14,0b,7f,01,41,18,0b,7f,01,41,1c,0b,7f,01,41,04,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,7f,01,41,00,0b,07,0e,02,04,6d,61,69,6e,00,00,03,6d,65,6d,02,00,0a,84,3f,52,25,02,01,7f,01,7f,41,08,28,00,00,21,00,41,08,20,00,6a,10,01,21,01,41,00,10,15,10,37,20,00,10,51,23,5f,23,37,6a,0b,26,01,01,7f,23,57,21,01,23,57,20,00,6a,24,57,23,57,23,00,6f,04,40,23,57,23,00,23,57,23,00,6f,6b,6a,24,57,0b,20,01,0b,22,01,01,7f,41,08,10,01,21,01,20,01,41,00,41,80,c4,fc,89,02,6b,36,00,00,20,01,41,04,6a,20,00,36,00,00,0b,19,01,01,7f,23,38,20,00,6a,10,01,21,01,20,01,23,37,6a,20,00,36,00,00,20,01,0b,0a,00,20,00,23,37,6a,28,00,00,0b,0d,00,20,00,23,38,20,01,6a,6a,2d,00,00,0b,0f,00,20,00,23,38,20,01,6a,6a,20,02,3a,00,00,0b,58,01,01,7f,20,01,20,00,10,04,4e,04,40,41,00,21,02,0b,20,01,20,02,6a,20,00,10,04,4e,04,40,20,00,10,04,20,01,6b,21,02,0b,20,02,10,03,21,03,02,40,03,40,20,02,41,00,46,04,40,0c,02,0b,20,02,41,01,6b,21,02,20,03,20,02,20,00,20,01,20,02,6a,10,05,10,06,0c,00,0b,0b,20,03,0b,56,03,01,7f,01,7f,01,7f,20,00,10,04,21,02,41,00,21,03,41,01,21,04,20,02,20,01,10,04,46,04,40,02,40,03,40,20,00,20,03,10,05,20,01,20,03,10,05,47,04,40,41,00,21,04,0c,02,0b,20,03,20,02,4e,04,40,0c,02,0b,20,03,41,01,6a,21,03,0c,00,0b,0b,05,41,00,21,04,0b,20,04,0b,37,02,01,7f,01,7f,41,01,21,02,20,00,10,04,21,03,20,03,41,00,46,20,03,41,04,4a,72,04,40,41,00,21,02,05,20,00,23,38,6a,28,00,00,20,01,47,04,40,41,00,21,02,0b,0b,20,02,0b,4c,02,01,7f,01,7f,41,01,21,03,20,00,10,04,21,04,20,04,41,05,48,20,04,41,08,4a,72,04,40,41,00,21,03,05,20,00,23,38,6a,28,00,00,20,01,47,04,40,41,00,21,03,0b,20,00,23,38,41,04,6a,6a,28,00,00,20,02,47,04,40,41,00,21,03,0b,0b,20,03,0b,58,01,01,7f,23,40,10,01,21,02,20,02,23,3f,6a,20,01,36,00,00,20,00,23,39,6a,28,00,00,45,04,40,20,00,23,39,6a,20,02,36,00,00,05,20,00,23,3a,6a,28,00,00,23,3d,6a,20,02,36,00,00,0b,20,00,23,3a,6a,20,02,36,00,00,20,00,23,3b,6a,20,00,23,3b,6a,28,00,00,41,01,6a,36,00,00,0b,62,01,01,7f,23,40,10,01,21,03,20,03,23,3f,6a,20,01,36,00,00,20,03,23,3e,6a,20,02,36,00,00,20,00,23,39,6a,28,00,00,45,04,40,20,00,23,39,6a,20,03,36,00,00,05,20,00,23,3a,6a,28,00,00,23,3d,6a,20,03,36,00,00,0b,20,00,23,3a,6a,20,03,36,00,00,20,00,23,3b,6a,20,00,23,3b,6a,28,00,00,41,01,6a,36,00,00,0b,4b,02,01,7f,01,7f,20,00,23,39,6a,28,00,00,21,02,41,00,21,03,02,40,03,40,20,02,45,04,40,0c,02,0b,20,02,23,3e,6a,28,00,00,20,01,10,08,04,40,20,02,23,3f,6a,28,00,00,21,03,0c,02,0b,20,02,23,3d,6a,28,00,00,21,02,0c,00,0b,0b,20,03,0b,44,01,01,7f,23,58,45,04,40,23,3c,10,01,24,58,0b,23,45,10,01,21,04,20,04,23,41,6a,20,00,36,00,00,20,04,23,42,6a,20,01,36,00,00,20,04,23,43,6a,20,02,36,00,00,20,04,23,44,6a,20,03,36,00,00,23,58,20,04,10,0b,0b,d3,04,01,01,7f,23,0f,21,03,20,00,41,28,10,09,04,40,23,12,21,03,0b,20,00,41,2c,10,09,04,40,23,13,21,03,0b,20,00,41,29,10,09,04,40,23,14,21,03,0b,20,00,41,e6,ea,b9,03,10,09,04,40,23,15,21,03,0b,20,00,41,f2,ca,d1,ab,07,41,f2,dc,01,10,0a,04,40,23,16,21,03,0b,20,00,41,e5,dc,91,b3,06,41,f5,dc,01,10,0a,04,40,23,17,21,03,0b,20,00,41,ec,de,bd,83,07,10,09,04,40,23,18,21,03,0b,20,00,41,e3,de,b9,a3,07,41,e9,dc,d5,ab,06,10,0a,04,40,23,19,21,03,0b,20,00,41,e2,e4,95,8b,06,41,eb,00,10,0a,04,40,23,1a,21,03,0b,20,00,41,e5,dc,91,e3,06,41,ef,de,c1,03,10,0a,04,40,23,1b,21,03,0b,20,00,41,e9,cc,01,10,09,04,40,23,1c,21,03,0b,20,00,41,f4,d0,95,f3,06,10,09,04,40,23,1d,21,03,0b,20,00,41,e5,d8,cd,ab,06,10,09,04,40,23,1f,21,03,0b,20,00,41,e5,d8,cd,ab,06,41,e9,cc,01,10,0a,04,40,23,1e,21,03,0b,20,00,41,e5,dc,91,cb,06,41,e6,00,10,0a,04,40,23,20,21,03,0b,20,00,41,e9,e6,c8,01,10,09,04,40,23,36,21,03,0b,20,00,41,e9,ec,d0,01,10,09,04,40,23,35,21,03,0b,20,00,41,e6,e6,c8,01,10,09,04,40,23,34,21,03,0b,20,00,41,e6,ec,d0,01,10,09,04,40,23,33,21,03,0b,20,00,41,ba,fa,00,10,09,04,40,23,22,21,03,0b,20,00,41,ef,e4,01,10,09,04,40,23,23,21,03,0b,20,00,41,e1,dc,91,03,10,09,04,40,23,24,21,03,0b,20,00,41,3d,10,09,04,40,23,25,21,03,0b,20,00,41,bc,fc,00,10,09,04,40,23,26,21,03,0b,20,00,41,3c,10,09,04,40,23,27,21,03,0b,20,00,41,bc,fa,00,10,09,04,40,23,28,21,03,0b,20,00,41,3e,10,09,04,40,23,29,21,03,0b,20,00,41,be,fa,00,10,09,04,40,23,2a,21,03,0b,20,00,41,bc,f8,00,10,09,04,40,23,2b,21,03,0b,20,00,41,be,fc,00,10,09,04,40,23,2c,21,03,0b,20,00,41,2b,10,09,04,40,23,2d,21,03,0b,20,00,41,2d,10,09,04,40,23,2e,21,03,0b,20,00,41,2a,10,09,04,40,23,2f,21,03,0b,20,00,41,2f,10,09,04,40,23,30,21,03,0b,20,00,41,ed,de,91,03,10,09,04,40,23,31,21,03,0b,20,00,41,ee,de,d1,03,10,09,04,40,23,32,21,03,0b,20,03,20,00,20,01,20,02,10,0e,0b,19,00,20,00,41,00,46,20,00,41,09,46,20,00,41,0d,46,20,00,41,20,46,72,72,72,0b,24,00,20,00,41,e1,00,4e,20,00,41,fa,00,4c,71,20,00,41,c1,00,4e,20,00,41,da,00,4c,71,20,00,41,df,00,46,72,72,0b,34,01,01,7f,41,00,21,02,20,00,41,30,4e,20,00,41,39,4c,71,04,40,41,01,21,02,05,20,01,20,00,41,e1,00,4e,20,00,41,e6,00,4c,71,71,04,40,41,01,21,02,0b,0b,20,02,0b,13,00,20,00,41,28,46,20,00,41,29,46,20,00,41,2c,46,72,72,0b,31,00,20,00,41,3d,46,20,00,41,2b,46,20,00,41,2d,46,20,00,41,2f,46,20,00,41,3c,46,20,00,41,3e,46,20,00,41,2a,46,20,00,41,3a,46,72,72,72,72,72,72,72,0b,ff,04,08,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,41,01,6b,21,01,41,01,21,02,41,00,21,03,20,00,10,04,21,04,41,00,21,05,41,00,21,06,41,00,21,07,41,00,21,08,02,40,03,40,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,20,00,20,01,10,05,21,05,20,05,10,10,04,40,0c,01,05,20,05,41,0a,46,04,40,20,02,41,01,6a,21,02,41,00,21,03,05,20,05,10,11,04,40,20,01,21,06,02,40,03,40,20,05,10,11,45,20,05,41,00,10,12,45,71,04,40,20,01,41,01,6b,21,01,20,03,41,01,6b,21,03,0c,02,0b,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,20,00,20,01,10,05,21,05,0c,00,0b,0b,20,00,20,06,20,01,20,06,6b,41,01,6a,10,07,21,07,20,07,20,02,20,03,10,0f,05,20,05,41,27,46,04,40,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,20,00,20,01,10,05,21,05,20,01,21,06,02,40,03,40,20,05,41,27,46,04,40,0c,02,0b,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,20,00,20,01,10,05,21,05,0c,00,0b,0b,20,00,20,06,20,01,20,06,6b,10,07,21,07,23,10,20,07,20,02,20,03,10,0e,05,20,05,41,00,10,12,20,05,41,2d,46,20,00,20,01,41,01,6a,10,05,41,00,10,12,71,72,04,40,20,01,21,06,41,00,21,08,02,40,03,40,20,05,20,08,10,12,45,20,05,41,2d,47,71,04,40,20,06,41,01,6a,20,01,46,20,05,41,f8,00,46,71,04,40,41,01,21,08,05,20,01,41,01,6b,21,01,20,03,41,01,6b,21,03,0c,03,0b,0b,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,20,00,20,01,10,05,21,05,0c,00,0b,0b,20,00,20,06,20,01,20,06,6b,41,01,6a,10,07,21,07,23,11,20,07,20,02,20,03,10,0e,05,20,05,41,2f,46,20,00,20,01,41,01,6a,10,05,41,2f,46,71,04,40,02,40,03,40,20,05,41,0a,46,20,05,41,0d,46,72,04,40,41,00,21,03,20,02,41,01,6a,21,02,0c,02,0b,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,20,00,20,01,10,05,21,05,0c,00,0b,0b,05,20,05,10,13,04,40,20,00,20,01,41,01,10,07,21,07,20,07,20,02,20,03,10,0f,05,20,05,10,14,04,40,20,00,20,01,41,01,6a,10,05,10,14,04,40,20,00,20,01,41,02,10,07,21,07,20,01,41,01,6a,21,01,20,03,41,01,6a,21,03,05,20,00,20,01,41,01,10,07,21,07,0b,20,07,20,02,20,03,10,0f,0b,0b,0b,0b,0b,0b,0b,0b,20,01,20,04,4e,04,40,0c,02,0b,0c,00,0b,0b,0b,50,01,01,7f,23,56,10,01,21,01,20,01,23,54,6a,23,3c,10,01,36,00,00,20,01,23,51,6a,20,00,36,00,00,23,5c,04,40,20,01,23,52,6a,23,5c,23,52,6a,28,00,00,41,01,6a,36,00,00,20,01,23,53,6a,23,5c,36,00,00,0b,20,00,23,4a,6a,20,01,36,00,00,20,01,24,5c,0b,11,00,23,5c,04,40,23,5c,23,53,6a,28,00,00,24,5c,0b,0b,37,01,01,7f,20,00,21,01,02,40,03,40,20,01,45,04,40,0c,02,0b,20,01,23,51,6a,28,00,00,23,46,6a,28,00,00,04,40,0c,02,0b,20,01,23,53,6a,28,00,00,21,01,0c,00,0b,0b,20,01,0b,67,03,01,7f,01,7f,01,7f,20,02,23,46,6a,28,00,00,21,03,41,00,21,04,41,00,21,05,20,00,23,54,6a,28,00,00,20,02,20,01,10,0c,20,03,23,0c,46,20,03,23,0d,46,72,04,40,20,00,10,18,21,04,20,04,23,55,6a,28,00,00,21,05,20,02,23,4a,6a,20,04,36,00,00,20,02,23,48,6a,20,05,36,00,00,20,04,23,55,6a,20,05,41,01,6a,36,00,00,0b,0b,3f,02,01,7f,01,7f,41,00,21,02,20,00,21,03,02,40,03,40,20,03,45,04,40,0c,02,0b,20,03,23,54,6a,28,00,00,20,01,10,0d,21,02,20,02,04,40,0c,02,0b,20,03,23,53,6a,28,00,00,21,03,0c,00,0b,0b,20,02,0b,16,01,01,7f,23,50,10,01,21,00,20,00,23,4a,6a,23,5c,36,00,00,20,00,0b,20,00,23,5a,23,3d,6a,28,00,00,24,5a,23,5a,04,40,23,5a,23,3f,6a,28,00,00,24,5b,05,41,00,24,5b,0b,0b,73,01,01,7f,20,00,23,41,6a,28,00,00,21,01,20,01,23,22,46,20,01,23,2d,46,20,01,23,2e,46,20,01,23,2f,46,20,01,23,30,46,20,01,23,31,46,20,01,23,23,46,20,01,23,24,46,20,01,23,27,46,20,01,23,25,46,20,01,23,26,46,20,01,23,27,46,20,01,23,28,46,20,01,23,29,46,20,01,23,2a,46,20,01,23,2b,46,20,01,23,2c,46,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,72,0b,19,01,01,7f,20,00,23,41,6a,28,00,00,21,01,20,01,23,2e,46,20,01,23,32,46,72,0b,1f,01,01,7f,20,00,23,41,6a,28,00,00,21,01,20,01,23,11,46,20,01,23,0f,46,20,01,23,10,46,72,72,0b,25,01,01,7f,20,00,23,41,6a,28,00,00,21,01,20,01,23,36,46,20,01,23,35,46,20,01,23,34,46,20,01,23,33,46,72,72,72,0b,2a,00,23,5b,23,41,6a,28,00,00,20,00,46,04,40,10,1c,05,41,99,01,10,02,20,00,10,02,23,5b,23,41,6a,28,00,00,10,02,23,5b,10,02,0b,0b,8c,01,04,01,7f,01,7f,01,7f,01,7f,23,3c,10,01,21,00,41,00,21,01,41,00,21,02,41,00,21,03,23,12,10,21,02,40,03,40,23,5b,23,41,6a,28,00,00,21,01,20,01,23,14,46,04,40,0c,02,0b,10,1c,10,1b,21,02,20,02,23,46,6a,23,0d,36,00,00,20,02,23,47,6a,20,01,36,00,00,23,5b,23,42,6a,28,00,00,21,03,20,02,23,49,6a,20,03,36,00,00,20,00,20,02,20,03,10,0c,10,1c,23,5b,23,41,6a,28,00,00,23,13,47,04,40,0c,02,0b,10,1c,0c,00,0b,0b,23,14,10,21,20,00,0b,68,03,01,7f,01,7f,01,7f,10,1b,21,00,23,3c,10,01,21,01,41,00,21,02,20,00,23,46,6a,23,02,36,00,00,20,00,23,4e,6a,20,01,36,00,00,20,00,23,4a,6a,23,5c,36,00,00,02,40,03,40,23,5b,45,04,40,0c,02,0b,23,5b,23,41,6a,28,00,00,23,17,46,04,40,0c,02,0b,10,36,21,02,20,02,45,04,40,0c,02,0b,20,01,20,02,10,0b,0c,00,0b,0b,20,00,0b,c3,01,05,01,7f,01,7f,01,7f,01,7f,01,7f,10,1b,21,02,23,3c,10,01,21,03,41,00,21,04,41,00,21,05,41,00,21,06,20,02,23,46,6a,23,0b,36,00,00,20,02,23,48,6a,23,59,36,00,00,23,59,41,01,6a,24,59,20,02,23,47,6a,20,00,36,00,00,20,02,23,49,6a,20,01,36,00,00,20,02,23,4e,6a,20,03,36,00,00,23,5c,20,01,20,02,10,19,10,22,21,04,20,02,23,4f,6a,20,04,36,00,00,20,02,10,16,20,04,23,39,6a,28,00,00,21,06,02,40,03,40,20,06,45,04,40,0c,02,0b,20,06,23,3e,6a,28,00,00,21,05,23,5c,20,05,20,06,23,3f,6a,28,00,00,10,19,20,06,23,3d,6a,28,00,00,21,06,0c,00,0b,0b,20,02,23,4b,6a,10,23,36,00,00,10,17,23,17,10,21,20,02,0b,33,02,01,7f,01,7f,41,00,21,00,41,00,21,01,23,5b,10,20,04,40,23,5b,23,41,6a,28,00,00,21,00,10,1c,0b,23,5b,23,42,6a,28,00,00,21,01,10,1c,20,00,20,01,10,24,0b,18,01,01,7f,10,1b,21,00,20,00,23,46,6a,23,09,36,00,00,23,1a,10,21,20,00,0b,18,01,01,7f,10,1b,21,00,20,00,23,46,6a,23,0a,36,00,00,23,19,10,21,20,00,0b,36,01,01,7f,10,1b,21,00,20,00,23,46,6a,23,0e,36,00,00,20,00,23,49,6a,23,5b,23,42,6a,28,00,00,36,00,00,20,00,23,47,6a,23,5b,23,41,6a,28,00,00,36,00,00,10,1c,20,00,0b,48,01,01,7f,23,3c,10,01,21,00,23,12,10,21,02,40,03,40,23,5b,23,41,6a,28,00,00,23,14,46,04,40,0c,02,0b,20,00,23,21,10,2f,10,0b,23,5b,23,41,6a,28,00,00,23,13,47,04,40,0c,02,0b,23,13,10,21,0c,00,0b,0b,23,14,10,21,20,00,0b,28,01,01,7f,10,1b,21,01,20,01,23,46,6a,23,05,36,00,00,20,01,23,4b,6a,20,00,36,00,00,20,01,23,4f,6a,10,29,36,00,00,20,01,0b,42,01,01,7f,10,1b,21,00,20,00,23,46,6a,23,04,36,00,00,20,00,23,47,6a,23,5b,23,41,6a,28,00,00,36,00,00,20,00,23,49,6a,23,5b,23,42,6a,28,00,00,36,00,00,10,1c,20,00,23,4c,6a,23,2d,10,2f,36,00,00,20,00,0b,3c,01,01,7f,41,00,21,00,23,5b,10,1f,04,40,10,28,21,00,05,23,5b,23,41,6a,28,00,00,23,12,46,04,40,10,1c,23,21,10,2f,21,00,23,14,10,21,05,23,5b,10,1e,04,40,10,2b,21,00,0b,0b,0b,20,00,0b,69,02,01,7f,01,7f,41,00,21,02,23,5b,23,41,6a,28,00,00,21,03,20,00,20,03,4a,04,40,20,01,21,02,05,10,1b,21,02,20,02,23,46,6a,23,03,36,00,00,20,02,23,47,6a,23,5b,23,41,6a,28,00,00,36,00,00,20,02,23,49,6a,23,5b,23,42,6a,28,00,00,36,00,00,20,02,23,4b,6a,20,01,36,00,00,10,1c,20,02,23,4c,6a,20,03,10,2f,36,00,00,0b,20,02,0b,33,01,01,7f,41,00,21,02,23,5b,10,1d,04,40,20,00,20,01,10,2d,21,02,05,23,5b,23,41,6a,28,00,00,23,12,46,04,40,20,01,10,2a,21,02,05,20,01,21,02,0b,0b,20,02,0b,66,03,01,7f,01,7f,01,7f,41,00,21,01,41,00,21,02,23,5b,23,41,6a,28,00,00,21,03,20,03,23,1a,46,04,40,10,26,21,01,05,20,03,23,19,46,04,40,10,27,21,01,05,10,2c,21,01,02,40,03,40,23,5b,45,04,40,0c,02,0b,20,00,20,01,10,2e,21,02,20,02,41,00,46,20,02,20,01,46,72,04,40,0c,02,0b,20,02,21,01,0c,00,0b,0b,0b,0b,20,01,0b,6e,02,01,7f,01,7f,10,1b,21,00,41,00,21,01,23,16,10,21,20,00,23,46,6a,23,06,36,00,00,20,00,23,4b,6a,23,21,10,2f,36,00,00,23,5c,21,01,02,40,03,40,20,01,45,04,40,0c,02,0b,20,01,23,51,6a,28,00,00,23,46,6a,28,00,00,23,0b,46,04,40,0c,02,0b,20,01,23,53,6a,28,00,00,21,01,0c,00,0b,0b,20,01,23,51,6a,28,00,00,23,4b,6a,20,00,36,00,00,20,00,0b,88,01,03,01,7f,01,7f,01,7f,10,1b,21,00,23,3c,10,01,21,01,41,00,21,02,20,00,23,46,6a,23,02,36,00,00,20,00,23,4e,6a,20,01,36,00,00,20,00,23,4a,6a,23,5c,36,00,00,02,40,03,40,23,5b,45,04,40,0c,02,0b,23,5b,23,41,6a,28,00,00,23,1f,46,04,40,0c,02,0b,23,5b,23,41,6a,28,00,00,23,1e,46,04,40,0c,02,0b,23,5b,23,41,6a,28,00,00,23,20,46,04,40,0c,02,0b,10,36,21,02,20,02,45,04,40,0c,02,0b,20,01,20,02,10,0b,0c,00,0b,0b,20,00,0b,8e,01,01,01,7f,10,1b,21,01,20,00,45,04,40,23,1c,10,21,0b,20,01,23,46,6a,23,07,36,00,00,20,01,23,4d,6a,23,21,10,2f,36,00,00,23,1d,10,21,20,01,10,16,20,01,23,4b,6a,10,31,36,00,00,10,17,23,5b,23,41,6a,28,00,00,23,1e,46,04,40,23,1e,10,21,20,01,10,16,20,01,23,4c,6a,41,01,10,32,36,00,00,10,17,0b,23,5b,23,41,6a,28,00,00,23,1f,46,04,40,23,1f,10,21,20,01,10,16,20,01,23,4c,6a,10,31,36,00,00,10,17,0b,20,00,45,04,40,23,20,10,21,0b,20,01,0b,68,03,01,7f,01,7f,01,7f,10,1b,21,00,23,3c,10,01,21,01,41,00,21,02,20,00,23,46,6a,23,02,36,00,00,20,00,23,4e,6a,20,01,36,00,00,20,00,23,4a,6a,23,5c,36,00,00,02,40,03,40,23,5b,45,04,40,0c,02,0b,23,5b,23,41,6a,28,00,00,23,1b,46,04,40,0c,02,0b,10,36,21,02,20,02,45,04,40,0c,02,0b,20,01,20,02,10,0b,0c,00,0b,0b,20,00,0b,2c,01,01,7f,10,1b,21,00,23,18,10,21,20,00,23,46,6a,23,08,36,00,00,20,00,10,16,20,00,23,4b,6a,10,33,36,00,00,10,17,23,1b,10,21,20,00,0b,a5,01,05,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,21,00,41,00,21,01,23,5b,23,41,6a,28,00,00,21,02,10,1c,23,5b,23,42,6a,28,00,00,21,03,10,1c,10,1b,21,04,20,04,23,46,6a,23,0c,36,00,00,20,04,23,47,6a,20,02,36,00,00,20,04,23,49,6a,20,03,36,00,00,23,5c,20,03,20,04,10,19,23,22,10,21,20,04,23,4c,6a,23,21,10,2f,36,00,00,23,5c,23,53,6a,28,00,00,04,40,23,5c,10,18,23,51,6a,28,00,00,21,00,20,00,23,4e,6a,28,00,00,21,01,20,01,45,04,40,23,3c,10,01,21,01,20,00,23,4e,6a,20,01,36,00,00,0b,20,01,20,04,10,0b,0b,20,04,0b,62,02,01,7f,01,7f,41,00,21,00,23,5b,23,41,6a,28,00,00,21,01,20,01,23,15,46,04,40,23,15,10,21,10,25,21,00,05,23,5b,10,20,04,40,10,35,21,00,05,20,01,23,16,46,04,40,10,30,21,00,05,20,01,23,1c,46,04,40,41,00,10,32,21,00,05,20,01,23,18,46,04,40,10,34,21,00,05,23,21,10,2f,21,00,0b,0b,0b,0b,0b,20,00,0b,66,02,01,7f,01,7f,10,1b,24,5e,23,58,23,39,6a,28,00,00,24,5a,23,5a,23,3f,6a,28,00,00,24,5b,23,5e,23,46,6a,23,01,36,00,00,23,5e,10,16,23,5c,24,5d,41,00,21,00,23,3c,10,01,21,01,23,5e,23,4e,6a,20,01,36,00,00,02,40,03,40,23,5b,45,04,40,0c,02,0b,10,36,21,00,20,00,45,04,40,0c,02,0b,20,01,20,00,10,0b,0c,00,0b,0b,0b,83,02,05,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,21,01,41,00,21,02,20,00,10,04,21,03,41,00,21,04,41,00,21,05,20,03,41,03,4e,04,40,20,00,41,00,10,05,41,30,46,20,00,41,01,10,05,41,f8,00,46,71,04,40,41,01,21,01,0b,0b,20,01,04,40,41,02,21,04,02,40,03,40,20,04,20,03,4e,04,40,0c,02,0b,20,02,41,10,6c,21,02,20,00,20,04,10,05,21,05,20,05,41,30,4e,20,05,41,39,4c,71,04,40,20,02,20,05,41,30,6b,6a,21,02,05,20,05,41,e1,00,4e,20,05,41,e6,00,4c,71,04,40,20,02,20,05,41,e1,00,6b,41,0a,6a,6a,21,02,0b,0b,20,04,41,01,6a,21,04,0c,00,0b,0b,05,02,40,03,40,20,04,20,03,4e,04,40,0c,02,0b,20,02,41,0a,6c,21,02,20,00,20,04,10,05,21,05,20,05,41,30,4e,20,05,41,39,4c,71,04,40,20,02,20,05,41,30,6b,6a,21,02,0b,20,04,41,01,6a,21,04,0c,00,0b,0b,0b,20,00,41,00,10,05,41,2d,46,04,40,41,00,20,02,6b,21,02,0b,20,02,0b,10,00,23,60,20,00,3a,00,00,23,60,41,01,6a,24,60,0b,10,00,23,60,20,00,36,00,00,23,60,41,04,6a,24,60,0b,4c,01,01,7f,41,00,21,01,20,00,41,ff,00,4c,04,40,41,01,21,01,05,20,00,41,ff,ff,00,4c,04,40,41,02,21,01,05,20,00,41,ff,ff,ff,00,4c,04,40,41,03,21,01,05,20,00,41,ff,ff,ff,ff,00,4c,04,40,41,04,21,01,05,41,05,21,01,0b,0b,0b,0b,20,01,0b,2d,00,02,40,03,40,20,00,41,80,01,48,04,40,0c,02,0b,41,80,01,20,00,41,80,01,6f,6a,10,39,20,00,41,80,01,6d,21,00,0c,00,0b,0b,20,00,10,39,0b,68,00,20,00,41,00,4e,04,40,02,40,03,40,20,00,41,c0,00,48,04,40,0c,02,0b,41,80,01,20,00,41,80,01,6f,6a,10,39,20,00,41,80,01,6d,21,00,0c,00,0b,0b,20,00,10,39,05,02,40,03,40,20,00,41,00,41,c0,00,6b,4e,04,40,0c,02,0b,20,00,41,80,01,6f,41,80,01,6b,10,39,20,00,41,80,01,6d,21,00,0c,00,0b,0b,20,00,41,80,01,6b,10,39,0b,0b,36,01,01,7f,23,60,21,02,20,01,41,00,4a,04,40,02,40,03,40,20,02,41,01,6b,21,02,20,02,20,00,48,04,40,0c,02,0b,20,02,20,01,6a,20,02,2d,00,00,3a,00,00,0c,00,0b,0b,0b,0b,71,03,01,7f,01,7f,01,7f,20,00,23,4f,6a,28,00,00,21,01,41,e0,00,10,39,20,01,23,3b,6a,28,00,00,10,3c,20,01,23,39,6a,28,00,00,21,02,02,40,03,40,20,02,45,04,40,0c,02,0b,20,02,23,3f,6a,28,00,00,23,47,6a,28,00,00,10,39,20,02,23,3d,6a,28,00,00,21,02,0c,00,0b,0b,20,00,23,47,6a,28,00,00,21,03,20,03,04,40,41,01,10,39,20,03,10,39,05,41,00,10,39,0b,0b,e8,01,08,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,21,00,41,00,21,01,41,00,21,02,41,00,21,03,41,00,21,04,41,00,21,05,23,5e,23,4e,6a,28,00,00,21,06,23,60,21,07,20,06,04,40,20,06,23,3b,6a,28,00,00,04,40,41,01,10,39,41,00,10,39,23,60,21,00,41,00,10,39,41,00,21,01,20,06,23,39,6a,28,00,00,21,02,02,40,03,40,20,02,23,3f,6a,28,00,00,21,03,20,03,23,46,6a,28,00,00,23,0b,46,04,40,20,03,10,3f,20,01,41,01,6a,21,01,23,62,41,01,6a,24,62,0b,20,02,23,3d,6a,28,00,00,21,02,20,02,45,04,40,0c,02,0b,0c,00,0b,0b,23,60,20,00,6b,21,04,20,01,10,3b,20,04,10,3b,41,02,6b,6a,21,05,20,00,20,05,10,3e,20,00,41,01,6b,24,60,20,04,10,3c,20,01,10,3c,23,60,20,04,41,01,6b,6a,24,60,0b,0b,23,62,45,04,40,20,07,24,60,0b,0b,74,04,01,7f,01,7f,01,7f,01,7f,41,00,21,00,41,00,21,01,41,00,21,02,41,00,21,03,23,62,04,40,41,03,10,39,41,00,10,39,23,60,21,00,23,62,10,3c,02,40,03,40,20,01,23,62,4e,04,40,0c,02,0b,20,01,10,3c,20,01,41,01,6a,21,01,0c,00,0b,0b,23,60,20,00,6b,21,02,20,02,10,3b,41,01,6b,21,03,20,00,20,03,10,3e,20,00,41,01,6b,24,60,20,02,10,3c,23,60,20,02,6a,24,60,0b,0b,17,00,41,05,10,39,41,03,10,3c,41,01,10,39,41,00,10,39,41,f0,00,10,39,0b,93,02,09,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,21,00,41,00,21,01,41,00,21,02,41,00,21,03,41,00,21,04,41,00,21,05,41,00,21,06,23,5e,23,4e,6a,28,00,00,21,07,23,60,21,08,20,07,04,40,20,07,23,3b,6a,28,00,00,04,40,41,06,10,39,41,00,10,39,23,60,21,00,41,00,10,39,20,07,23,39,6a,28,00,00,21,02,02,40,03,40,20,02,23,3f,6a,28,00,00,21,03,20,03,23,46,6a,28,00,00,23,0c,46,04,40,20,03,23,47,6a,28,00,00,10,39,41,01,10,39,41,c1,00,10,39,20,03,23,4c,6a,28,00,00,23,49,6a,28,00,00,21,04,20,04,10,38,10,3d,41,0b,10,39,20,01,41,01,6a,21,01,23,61,41,01,6a,24,61,0b,20,02,23,3d,6a,28,00,00,21,02,20,02,45,04,40,0c,02,0b,0c,00,0b,0b,23,60,20,00,6b,21,05,20,01,10,3b,20,05,10,3b,41,02,6b,6a,21,06,20,00,20,06,10,3e,20,00,41,01,6b,24,60,20,05,10,3c,20,01,10,3c,23,60,20,05,41,01,6b,6a,24,60,0b,0b,23,61,45,04,40,20,08,24,60,0b,0b,ad,01,05,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,21,00,41,00,21,01,41,00,21,02,41,00,21,03,23,5e,23,4e,6a,28,00,00,21,04,20,04,04,40,20,04,23,3b,6a,28,00,00,21,00,20,00,04,40,41,07,10,39,41,00,10,39,23,60,21,01,41,02,10,39,41,04,10,39,41,ed,00,10,39,41,e1,00,10,39,41,e9,00,10,39,41,ee,00,10,39,41,00,10,39,41,00,10,3c,41,03,10,39,41,ed,00,10,39,41,e5,00,10,39,41,ed,00,10,39,41,02,10,39,41,00,10,39,23,60,20,01,6b,21,02,20,02,10,3b,41,01,6b,21,03,20,01,20,03,10,3e,20,01,41,01,6b,24,60,20,02,10,3c,23,60,20,02,6a,24,60,0b,0b,0b,43,01,01,7f,23,5c,20,00,23,4b,6a,28,00,00,23,49,6a,28,00,00,10,1a,21,01,20,00,23,4c,6a,28,00,00,10,4e,20,01,23,4a,6a,28,00,00,23,5d,46,04,40,41,24,10,39,05,41,21,10,39,0b,20,01,23,48,6a,28,00,00,10,3c,0b,d2,01,00,20,00,23,25,46,04,40,41,c6,00,10,39,0b,20,00,23,26,46,04,40,41,c7,00,10,39,0b,20,00,23,27,46,04,40,41,c8,00,10,39,0b,20,00,23,28,46,04,40,41,cc,00,10,39,0b,20,00,23,29,46,04,40,41,ca,00,10,39,0b,20,00,23,2a,46,04,40,41,ce,00,10,39,0b,20,00,23,2d,46,04,40,41,ea,00,10,39,0b,20,00,23,2e,46,04,40,41,eb,00,10,39,0b,20,00,23,2f,46,04,40,41,ec,00,10,39,0b,20,00,23,30,46,04,40,41,ed,00,10,39,0b,20,00,23,31,46,04,40,41,ef,00,10,39,0b,20,00,23,24,46,04,40,41,f1,00,10,39,0b,20,00,23,23,46,04,40,41,f2,00,10,39,0b,20,00,23,32,46,04,40,41,c5,00,10,39,0b,20,00,23,2b,46,04,40,41,f4,00,10,39,0b,20,00,23,2c,46,04,40,41,f5,00,10,39,0b,0b,2d,01,01,7f,20,00,23,47,6a,28,00,00,21,01,20,01,23,2e,46,04,40,41,c1,00,10,39,41,00,10,39,0b,20,00,23,4c,6a,28,00,00,10,4e,20,01,10,46,0b,91,01,03,01,7f,01,7f,01,7f,20,00,23,47,6a,28,00,00,21,01,41,00,21,02,41,00,21,03,20,01,23,11,46,04,40,41,c1,00,10,39,20,00,23,49,6a,28,00,00,10,38,21,02,20,02,10,3d,05,20,01,23,0f,46,04,40,23,5c,20,00,23,49,6a,28,00,00,10,1a,21,03,20,03,23,4a,6a,28,00,00,23,5d,46,04,40,41,23,10,39,05,41,20,10,39,0b,20,03,23,48,6a,28,00,00,10,3c,05,20,01,23,10,46,04,40,41,c1,00,10,39,20,00,23,49,6a,28,00,00,23,38,6a,28,00,00,21,02,20,02,10,3d,0b,0b,0b,0b,e3,01,04,01,7f,01,7f,01,7f,01,7f,20,00,23,4f,6a,28,00,00,21,01,20,01,23,39,6a,28,00,00,21,02,41,00,21,03,02,40,03,40,20,02,45,04,40,0c,02,0b,20,02,23,3f,6a,28,00,00,10,4e,20,02,23,3d,6a,28,00,00,21,02,0c,00,0b,0b,20,00,23,4b,6a,28,00,00,23,49,6a,28,00,00,21,04,20,04,41,f3,e8,bd,93,07,41,e5,e6,c8,01,10,0a,04,40,41,36,10,39,41,00,10,39,41,00,10,39,05,20,04,41,f3,e8,bd,93,07,41,e5,f0,00,10,0a,04,40,41,3a,10,39,41,00,10,39,41,00,10,39,05,20,04,41,ec,de,85,a3,06,41,b3,e4,00,10,0a,04,40,41,28,10,39,41,00,10,39,41,00,10,39,05,20,04,41,ec,de,85,a3,06,41,38,10,0a,04,40,41,2d,10,39,41,00,10,39,41,00,10,39,05,23,5c,20,04,10,1a,21,03,41,10,10,39,20,03,23,48,6a,28,00,00,10,3c,0b,0b,0b,0b,0b,7a,05,01,7f,01,7f,01,7f,01,7f,01,7f,20,00,23,46,6a,28,00,00,21,01,20,00,23,47,6a,28,00,00,21,02,20,00,23,4a,6a,28,00,00,21,03,20,03,04,40,20,03,24,5c,0b,20,00,23,4e,6a,28,00,00,21,04,20,04,23,39,6a,28,00,00,21,05,02,40,03,40,20,05,45,04,40,0c,02,0b,20,05,23,3f,6a,28,00,00,10,4e,20,05,23,3d,6a,28,00,00,21,05,0c,00,0b,0b,20,03,04,40,23,5c,23,53,6a,28,00,00,24,5c,0b,0b,3c,01,01,7f,20,00,23,4d,6a,28,00,00,10,4e,41,04,10,39,41,c0,00,10,39,20,00,23,4b,6a,28,00,00,10,4e,20,00,23,4c,6a,28,00,00,21,01,20,01,04,40,41,05,10,39,20,01,10,4e,0b,41,0b,10,39,0b,47,02,01,7f,01,7f,23,5c,21,00,41,00,21,01,02,40,03,40,20,00,45,04,40,0c,02,0b,20,00,23,51,6a,28,00,00,23,46,6a,28,00,00,23,08,46,04,40,0c,02,0b,20,01,41,01,6a,21,01,20,00,23,53,6a,28,00,00,21,00,0c,00,0b,0b,20,01,0b,2e,00,41,02,10,39,41,c0,00,10,39,41,03,10,39,41,c0,00,10,39,20,00,23,4b,6a,28,00,00,10,4e,41,0c,10,39,41,00,10,39,41,0b,10,39,41,0b,10,39,0b,ee,01,02,01,7f,01,7f,20,00,23,46,6a,28,00,00,21,01,20,00,23,47,6a,28,00,00,21,02,20,01,23,02,46,04,40,20,00,10,4a,05,20,01,23,03,46,04,40,20,02,23,22,46,04,40,20,00,10,45,05,20,00,23,4b,6a,28,00,00,10,4e,20,00,23,4c,6a,28,00,00,10,4e,20,02,10,46,0b,05,20,01,23,04,46,04,40,20,00,10,47,05,20,01,23,05,46,04,40,20,00,10,49,05,20,01,23,06,46,04,40,20,00,23,4b,6a,28,00,00,10,4e,05,20,01,23,07,46,04,40,20,00,10,4b,05,20,01,23,08,46,04,40,20,00,10,4d,05,20,01,23,09,46,04,40,41,0c,10,39,10,4c,41,01,6a,10,3c,05,20,01,23,0a,46,04,40,41,0c,10,39,10,4c,10,3c,05,20,01,23,0e,46,04,40,20,00,10,48,05,20,01,23,0c,46,04,40,20,00,23,4c,6a,28,00,00,10,4e,41,21,10,39,20,00,23,48,6a,28,00,00,10,3c,0b,0b,0b,0b,0b,0b,0b,0b,0b,0b,0b,0b,96,01,05,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,10,39,23,60,21,01,20,00,23,4e,6a,28,00,00,21,02,20,02,23,3b,6a,28,00,00,10,3c,20,02,23,39,6a,28,00,00,21,03,02,40,03,40,20,03,45,04,40,0c,02,0b,41,01,10,39,20,03,23,3f,6a,28,00,00,23,47,6a,28,00,00,10,39,20,03,23,3d,6a,28,00,00,21,03,0c,00,0b,0b,20,00,23,4b,6a,28,00,00,10,4e,41,0b,10,39,23,60,20,01,6b,21,04,20,04,10,3b,41,01,6b,21,05,20,01,20,05,10,3e,20,01,41,01,6b,24,60,20,04,10,3c,23,60,20,04,6a,24,60,0b,ad,01,06,01,7f,01,7f,01,7f,01,7f,01,7f,01,7f,41,00,21,00,41,00,21,01,41,00,21,02,41,00,21,03,41,00,21,04,41,00,21,05,23,62,04,40,41,0a,10,39,41,00,10,39,23,60,21,00,23,62,10,3c,23,5e,23,4e,6a,28,00,00,21,01,20,01,23,39,6a,28,00,00,21,02,02,40,03,40,20,02,23,3f,6a,28,00,00,21,03,20,03,23,46,6a,28,00,00,23,0b,46,04,40,20,03,10,4f,0b,20,02,23,3d,6a,28,00,00,21,02,20,02,45,04,40,0c,02,0b,0c,00,0b,0b,23,60,20,00,6b,21,04,20,04,10,3b,41,01,6b,21,05,20,00,20,05,10,3e,20,00,41,01,6b,24,60,20,04,10,3c,23,60,20,04,6a,24,60,0b,0b,50,00,20,00,41,80,02,6a,10,03,24,5f,23,5f,23,38,6a,24,60,23,5e,23,4a,6a,28,00,00,24,5c,41,00,10,39,41,e1,00,10,39,41,f3,00,10,39,41,ed,00,10,39,41,01,10,3a,10,40,10,41,10,42,10,43,10,44,10,50,23,5f,23,37,6a,23,60,23,5f,23,38,6a,6b,36,00,00,0b</textarea></td>
      </tr><tr>
        <td colspan="2" align="center"><button id="compile">Compile</button></td>
      </tr><tr>
        <td>Code to compile</td>
        <td>Compiled binary</td>
      </tr><tr>
        <td><textarea id="code">i32 MemPointer := 0

fun i32 main()
  emitSleb(16384)
  emitByte(0x00)
  emitSleb(0 - 16384)
  return MemPointer
endfun

fun emitByte(i32 byte)
  store8(MemPointer, byte)
  MemPointer:= MemPointer + 1
endfun

fun emitSleb(i32 i)
  if i >= 0 then 
    loop
      if i < 64 then break endif
      emitByte(128 + i mod 128)
      i := i / 128
    endloop
    emitByte(i)
  else
    loop
      if i >= (0 - 64) then break endif
      emitByte(i mod 128 - 128)
      i := i / 128
    endloop
    emitByte(i - 128)
  endif
endfun
         </textarea></td>
        <td><textarea id="binary"></textarea></td>
      </tr><tr>
        <td colspan="2" align="center"><button id="execute">Execute</button></td>
      </tr><tr>
        <td>Memory dump</td>
        <td>main() result</td>
      </tr><tr>
        <td><textarea id="execMemDump"></textarea></td>
        <td><textarea id="execResult"></textarea></td>
      </tr>
    </table>
    <style>
      textarea {
        height: 500px;
        width: 100%;
      }
      pre {
       max-height: 30em;
       overflow: auto;
      }
    </style>
    <script src="prism.js"></script>
    <script>
      if (window.WebAssembly === void 0) {
        alert("Your browser doesn't support WebAssembly!");
      }
      function hexStringToByte(str) {
        if (!str) {
          return new Uint8Array();
        }
        var a = [];
        for (var i = 0, len = str.length; i < len; i+=2) {
          a.push(parseInt(str.substr(i,2),16));
        }
        return new Uint8Array(a);
      };
      function byteToHexString(uint8arr) {
        if (!uint8arr) {
          return '';
        }
        var hexStr = '';
        for (var i = 0; i < uint8arr.length; i++) {
          var hex = (uint8arr[i] & 0xff).toString(16);
          hex = (hex.length === 1) ? '0' + hex : hex;
          hexStr += hex + ',';
        }
        return hexStr.slice(0, -1);
      }
      compile.onclick = (e) => {
        var bytes = compilerBinary.value;
        bytes = hexStringToByte(bytes.replace(/,/g, ""));
        WebAssembly.instantiate(bytes).then(results => {
          let main = results.instance.exports.main;
          let mem = new Uint8Array(results.instance.exports.mem.buffer);
          let sourcecode = code.value;
          new Uint32Array(mem.buffer)[2] = sourcecode.length;
          for (var i = 0, strLen = sourcecode.length; i < strLen; i++) { mem[i+12] = sourcecode.charCodeAt(i); }
          let out = main();
          let binLen = mem[out] + 256*mem[out + 1] + 256*256*mem[out + 2] + 256*256*256*mem[out + 3];
          out = out + 4;
          binary.value = byteToHexString(mem.slice(out, out + binLen));
        });
      };
      execute.onclick = (e) => {
        var bytes = binary.value;
        bytes = hexStringToByte(bytes.replace(/,/g, ""));
        WebAssembly.instantiate(bytes).then(results => {
          let main = results.instance.exports.main;
          let mem = new Uint8Array(results.instance.exports.mem.buffer);
          let out = main();
          execResult.value = out;
          execMemDump.value = byteToHexString(mem.slice(0, 2000));
        });
      };
    </script>
  </body>
</html>
