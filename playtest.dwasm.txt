// dwasm code example
// Calculate 1 million SHA256 hashes
// 0x00 ~ 0x3f will be used as input chunk
// 0x80 ~ 0x9f will be used as output value
// 0x100 ~ 0x1ff will be used to store round constants

memory 1 export "mem"

// Data section for round constant
// Note that wasm stores numbers in little-endian order

data 0x100 "\98\2f\8a\42\91\44\37\71\cf\fb\c0\b5\a5\db\b5\e9\5b\c2\56\39\f1\11\f1\59\a4\82\3f\92\d5\5e\1c\ab\98\aa\07\d8\01\5b\83\12\be\85\31\24\c3\7d\0c\55\74\5d\be\72\fe\b1\de\80\a7\06\dc\9b\74\f1\9b\c1\c1\69\9b\e4\86\47\be\ef\c6\9d\c1\0f\cc\a1\0c\24\6f\2c\e9\2d\aa\84\74\4a\dc\a9\b0\5c\da\88\f9\76\52\51\3e\98\6d\c6\31\a8\c8\27\03\b0\c7\7f\59\bf\f3\0b\e0\c6\47\91\a7\d5\51\63\ca\06\67\29\29\14\85\0a\b7\27\38\21\1b\2e\fc\6d\2c\4d\13\0d\38\53\54\73\0a\65\bb\0a\6a\76\2e\c9\c2\81\85\2c\72\92\a1\e8\bf\a2\4b\66\1a\a8\70\8b\4b\c2\a3\51\6c\c7\19\e8\92\d1\24\06\99\d6\85\35\0e\f4\70\a0\6a\10\16\c1\a4\19\08\6c\37\1e\4c\77\48\27\b5\bc\b0\34\b3\0c\1c\39\4a\aa\d8\4e\4f\ca\9c\5b\f3\6f\2e\68\ee\82\8f\74\6f\63\a5\78\14\78\c8\84\08\02\c7\8c\fa\ff\be\90\eb\6c\50\a4\f7\a3\f9\be\f2\78\71\c6"

i32 message_len = 64
i32 h0 = 0x6a09e667
i32 h1 = 0xbb67ae85
i32 h2 = 0x3c6ef372
i32 h3 = 0xa54ff53a
i32 h4 = 0x510e527f
i32 h5 = 0x9b05688c
i32 h6 = 0x1f83d9ab
i32 h7 = 0x5be0cd19

func i32 main() export
  i32 i = 0
  loop
    breakif i >= 1000000
    i = i + 1
    sha256_end(64)
  end
  return i
end

func i32 get_word(i32 w)
  return flip_endian(load32((w and 0x0f) * 4))
end

func set_word(i32 w, i32 v)
  store32((w and 0x0f) * 4, v)
end

func i32 get_constant(i32 w)
  return load32(0x100 + w * 4)
end

// once i32.bswap is landed, this function is useless
func i32 flip_endian(i32 w)
  return ((w and 0xff000000) >>+ 24) or
         ((w and 0x00ff0000) >>+  8) or
         ((w and 0x0000ff00) <<   8) or
         ((w and 0x000000ff) <<  24)
end

// process full block
func sha256_update() export
  message_len = message_len + 64
  i32 a = h0
  i32 b = h1
  i32 c = h2
  i32 d = h3
  i32 e = h4
  i32 f = h5
  i32 g = h6
  i32 h = h7
  i32 w = 0
  i32 s0 = 0
  i32 s1 = 0
  loop

    // word 0 ~ 15 will be used as-is on memory
    // word 16 ~ 63 will be calculated and replaced on memory
    if 16 <= w then
      // calculate word to use
      s0 = get_word(w - 15)
      s1 = get_word(w - 2)
      s0 = s0 >-> 7  xor s0 >-> 18 xor s0 >> 3
      s1 = s1 >-> 17 xor s1 >-> 19 xor s1 >> 10
      set_word(w, get_word(w - 16) + s0 + get_word(w - 7) + s1)
    end

    // compress
    s1 = e >-> 6 xor e >-> 11 xor e >-> 25
    i32 ch = (e and f) xor (-e and g) 
    i32 temp1 = h + s1 + ch + get_constant(w) + get_word(w)
    s0 = a >-> 2 xor a >-> 13 xor a >-> 22
    i32 maj = (a and b) xor (a and c) xor (b and c)
    i32 temp2 = s0 + maj

    // rotate variables
    h = g
    g = f
    f = e
    e = d + temp1
    d = c
    c = b
    b = a
    a = temp1 + temp2

    w = w + 1
    breakif w >= 64

  end

  // feed to h0 ~ h7
  h0 = a + h0
  h1 = b + h1
  h2 = c + h2
  h3 = d + h3
  h4 = e + h4
  h5 = f + h5
  h6 = g + h6
  h7 = h + h7
end

// input  - length of final chunk
func sha256_end(i32 final_len)
  i32 total_len = message_len + final_len
  store8(final_len, 0x80)
  i32 i = final_len + 1
  if i > 56 then          
    loop  // zero pad
      breakif i >= 64
      store8(i, 0)
      i = i + 1
    end
    sha256_update()

    // fill 14 words with 0
    store64(0x00, 0)
    store64(0x08, 0)
    store64(0x16, 0)
    store64(0x24, 0)
    store64(0x30, 0)      
  else
    loop 
      breakif i >= 56
      store8(i, 0)
      i = i + 1
    end
  end

  // append length (in bits)
  set_word(14, 0)
  set_word(15, total_len * 8)

  // update final block
  sha256_update()

  // copy h0~7 to memory
  store32(0x80, h0)
  store32(0x84, h1)
  store32(0x88, h2)
  store32(0x8c, h3)
  store32(0x90, h4)
  store32(0x94, h5)
  store32(0x98, h6)
  store32(0x9c, h7)
end
